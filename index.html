<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CYBER-HAND V100: ARCHITECT</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #050505; 
            font-family: 'Segoe UI', monospace; color: white; 
            user-select: none; -webkit-user-select: none;
            touch-action: none; 
        }
        
        #bg-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; 
            background: radial-gradient(circle at center, #1a1a1a 0%, #000 100%);
        }

        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        #video-feed { 
            position: absolute; bottom: 20px; left: 20px; width: 120px; z-index: 2; 
            border-radius: 12px; border: 1px solid rgba(0, 255, 255, 0.3); 
            transform: scaleX(-1); opacity: 0.6; pointer-events: none;
        }
        
        #ui-panel { 
            position: absolute; top: 10px; right: 10px; width: 90%; max-width: 300px;
            padding: 15px; background: rgba(10, 10, 15, 0.90); 
            backdrop-filter: blur(20px); border-radius: 16px; 
            border: 1px solid rgba(0, 255, 255, 0.2); 
            z-index: 10; transition: transform 0.3s ease;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.1);
            max-height: 85vh; overflow-y: auto;
        }
        
        .header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px; margin-bottom: 15px; }
        h2 { margin: 0; font-size: 14px; color: #00ffff; letter-spacing: 2px; text-shadow: 0 0 10px rgba(0,255,255,0.5); }
        
        .control-row { margin-bottom: 15px; }
        .label { display: flex; justify-content: space-between; font-size: 10px; color: #aaa; margin-bottom: 5px; text-transform: uppercase; }
        
        input[type=range] { width: 100%; -webkit-appearance: none; background: #333; height: 3px; border-radius: 2px; outline: none; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; background: #00ffff; border-radius: 50%; cursor: pointer; box-shadow: 0 0 10px #00ffff; border: 2px solid #000;}
        
        .mode-switch { display: flex; gap: 5px; margin-bottom: 15px; background: #000; padding: 4px; border-radius: 8px; border: 1px solid #333; }
        .mode-btn { 
            flex: 1; padding: 10px; border: none; background: transparent; color: #666; 
            font-size: 10px; font-weight: bold; cursor: pointer; border-radius: 6px; transition: 0.2s; 
        }
        .mode-btn.active { background: #00ffff; color: #000; box-shadow: 0 0 15px rgba(0,255,255,0.4); }

        .file-upload {
            display: block; width: 100%; padding: 12px 0; text-align: center;
            background: rgba(0, 255, 255, 0.05); border: 1px dashed #00ffff;
            color: #00ffff; font-size: 10px; cursor: pointer; border-radius: 6px;
            transition: 0.2s; margin-bottom: 8px; box-sizing: border-box;
            text-shadow: 0 0 5px rgba(0,255,255,0.3);
        }
        .file-upload:hover { background: rgba(0, 255, 255, 0.15); box-shadow: 0 0 15px rgba(0,255,255,0.2); }
        input[type="file"] { display: none; }
        input[type="color"] { border: none; width: 100%; height: 30px; background: none; cursor: pointer; padding: 0;}

        .shape-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-top: 15px; }
        .shape-btn { background: #111; border: 1px solid #333; color: #ccc; padding: 10px; border-radius: 4px; cursor: pointer; font-size: 10px; transition: 0.2s; text-transform: uppercase;}
        .shape-btn:hover { border-color: #fff; }
        .shape-btn.active { border-color: #00ffff; color: #00ffff; box-shadow: inset 0 0 10px rgba(0,255,255,0.2); }

        #clear-btn { width: 100%; padding: 12px; background: #300; color: #f55; margin-top: 5px; border: 1px solid #600; border-radius: 6px; cursor: pointer;}
        
        /* –ò–ù–î–ò–ö–ê–¢–û–† –†–ï–ñ–ò–ú–ê (CINEMATIC) */
        #cinematic-mode {
            position: absolute; top: 10%; left: 50%; transform: translateX(-50%);
            font-size: 24px; font-weight: 800; color: #fff; letter-spacing: 4px;
            text-shadow: 0 0 20px rgba(0,255,255,0.8);
            opacity: 0; transition: opacity 0.5s; pointer-events: none; z-index: 20;
        }

        #loader { position: absolute; top:0; left:0; width:100%; height:100%; background:#000; z-index:99; display:flex; flex-direction:column; justify-content:center; align-items:center; color:#00ffff; font-size:14px; transition: opacity 0.5s; text-align: center; }
        
        #start-screen { position: absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.95); z-index: 999; display:flex; justify-content:center; align-items:center; cursor:pointer; flex-direction: column;}
        #start-btn { font-size: 20px; border: 2px solid #00ffff; color: #00ffff; padding: 15px 40px; border-radius: 50px; background: transparent; transition: 0.3s; box-shadow: 0 0 20px rgba(0,255,255,0.2); text-transform: uppercase; letter-spacing: 2px;}
        #start-btn:hover { background: #00ffff; color: #000; box-shadow: 0 0 50px rgba(0,255,255,0.8); }
        
        #ui-hint { position: absolute; top: 20px; right: 20px; color: rgba(255,255,255,0.3); font-size: 12px; display: none; pointer-events: none; z-index: 5; }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/examples/jsm/loaders/OBJLoader.js": "https://unpkg.com/three@0.128.0/examples/jsm/loaders/OBJLoader.js",
                "three/examples/jsm/postprocessing/EffectComposer.js": "https://unpkg.com/three@0.128.0/examples/jsm/postprocessing/EffectComposer.js",
                "three/examples/jsm/postprocessing/RenderPass.js": "https://unpkg.com/three@0.128.0/examples/jsm/postprocessing/RenderPass.js",
                "three/examples/jsm/postprocessing/UnrealBloomPass.js": "https://unpkg.com/three@0.128.0/examples/jsm/postprocessing/UnrealBloomPass.js"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js"></script>
</head>
<body>

    <div id="bg-layer"></div>
    <div id="loader"><div>–ó–ê–ì–†–£–ó–ö–ê –Ø–î–†–ê...</div><div style="font-size:10px; color:#666; margin-top:5px;">–†–∞–∑—Ä–µ—à–∏—Ç–µ –¥–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ</div></div>
    <div id="cinematic-mode">SYSTEM READY</div>

    <div id="start-screen">
        <button id="start-btn">–ó–ê–ü–£–°–ö –°–ò–°–¢–ï–ú–´</button>
        <div style="margin-top:20px; color:#555; font-size:11px;">DEBUG | BLOOM | HOLO | GESTURES 2.0</div>
    </div>

    <div id="ui-hint">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</div>

    <div id="ui-panel">
        <div class="header">
            <h2>V100 ARCHITECT</h2>
            <button onclick="document.getElementById('ui-panel').style.transform = 'translateX(120%)'; document.getElementById('ui-hint').style.display='block';" style="background:none; border:none; color:#0ff; cursor:pointer; font-size:16px;">‚úï</button>
        </div>

        <div class="mode-switch">
            <button class="mode-btn active" id="btn-view">üëÅ –ü–†–û–°–ú–û–¢–†</button>
            <button class="mode-btn" id="btn-draw">üñå –†–ò–°–û–í–ê–ù–ò–ï</button>
        </div>

        <div id="view-controls">
            <!-- –ö–ù–û–ü–ö–ê –û–¢–õ–ê–î–ö–ò -->
            <button class="file-upload" onclick="window.toggleDebugWindow()" style="border-color: #0f0; color: #0f0; margin-bottom: 15px; font-weight:bold;">
                üìü –û–¢–ö–†–´–¢–¨ –û–ö–ù–û –û–¢–õ–ê–î–ö–ò
            </button>

            <label class="file-upload">
                üì• –ó–ê–ì–†–£–ó–ò–¢–¨ 3D –ú–û–î–ï–õ–¨ (.OBJ)
                <input type="file" id="obj-input" accept=".obj">
            </label>
            
            <label class="file-upload" style="border-color: #ff00ff; color: #ff00ff;">
                üñº –ó–ê–ì–†–£–ó–ò–¢–¨ –¢–ï–ö–°–¢–£–†–£
                <input type="file" id="tex-input" accept="image/*">
            </label>

            <div class="control-row">
                <div class="label"><span>–¶–≤–µ—Ç</span></div>
                <input type="color" id="color-input" value="#00ffff">
            </div>

            <div class="control-row">
                <div class="label"><span>–°–≤–µ—á–µ–Ω–∏–µ (Bloom)</span><span id="val-bloom">1.5</span></div>
                <input type="range" id="bloom-slider" min="0" max="3" step="0.1" value="1.5">
            </div>

            <div class="control-row">
                <div class="label"><span>–†–∞–∑–º–µ—Ä —á–∞—Å—Ç–∏—Ü</span><span id="val-size">0.06</span></div>
                <input type="range" id="size-slider" min="0.01" max="0.2" step="0.01" value="0.06">
            </div>

            <div class="control-row">
                <div class="label"><span>–ò–Ω–µ—Ä—Ü–∏—è</span><span id="val-fric">0.95</span></div>
                <input type="range" id="fric-slider" min="0.80" max="0.99" step="0.01" value="0.95">
            </div>

            <div class="shape-grid">
                <button class="shape-btn" data-shape="holo" style="grid-column: span 2; border: 1px dashed #00ffff; color:#00ffff;">üë§ –ì–û–õ–û–ì–†–ê–ú–ú–ê</button>
                <button class="shape-btn active" data-shape="sphere">–°—Ñ–µ—Ä–∞</button>
                <button class="shape-btn" data-shape="galaxy">–ì–∞–ª–∞–∫—Ç–∏–∫–∞</button>
                <button class="shape-btn" data-shape="dna">–î–ù–ö</button>
                <button class="shape-btn" data-shape="cube">–ö—É–±</button>
            </div>
        </div>

        <div id="draw-controls" style="display:none;">
            <div style="text-align:center; font-size:11px; color:#fff; margin-bottom:10px; background: rgba(0,255,255,0.1); padding: 10px; border-radius: 6px;">
                ‚òùÔ∏è <b>–£–∫–∞–∑–∞—Ç–µ–ª—å–Ω—ã–π –ø–∞–ª–µ—Ü</b> ‚Äî –†–∏—Å–æ–≤–∞—Ç—å<br>
                ‚úåÔ∏è <b>–ñ–µ—Å—Ç "–û–ö"</b> ‚Äî –°–æ—Ö—Ä–∞–Ω–∏—Ç—å
            </div>
            <button id="clear-btn">–û–ß–ò–°–¢–ò–¢–¨</button>
        </div>
    </div>

    <video id="video-feed" playsinline webkit-playsinline></video>
    <div id="canvas-container" onclick="document.getElementById('ui-panel').style.transform = 'translateX(0)'; document.getElementById('ui-hint').style.display='none';"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader.js';
        import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';

        // --- AUDIO SYSTEM ---
        window.AudioSys = {
            ctx: null, masterGain: null, active: false,
            init: function() {
                if(this.active) return;
                const AC = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AC();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.2;
                this.masterGain.connect(this.ctx.destination);
                this.active = true;
                document.getElementById('start-screen').style.display = 'none';
                if(this.ctx.state === 'suspended') this.ctx.resume();
            },
            playTone: function(freq, type='sine') {
                if(!this.active) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                osc.type = type; osc.frequency.setValueAtTime(freq, t);
                const g = this.ctx.createGain();
                g.gain.setValueAtTime(0.1, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.2);
                osc.connect(g); g.connect(this.masterGain);
                osc.start(); osc.stop(t+0.2);
            }
        };

        // --- DEBUG WINDOW SYSTEM ---
        let debugWin = null;
        let debugCtx = null;
        let debugCanvas = null;

        window.toggleDebugWindow = function() {
            if (debugWin && !debugWin.closed) { debugWin.close(); debugWin = null; return; }
            debugWin = window.open('', 'CyberHandDebug', 'width=640,height=480,menubar=no,toolbar=no');
            if (!debugWin) { alert("–†–∞–∑—Ä–µ—à–∏—Ç–µ –≤—Å–ø–ª—ã–≤–∞—é—â–∏–µ –æ–∫–Ω–∞!"); return; }
            debugWin.document.write(`<html><head><title>DEBUG</title><style>body{background:#111;margin:0;display:flex;justify-content:center;align-items:center;height:100vh;}canvas{border:2px solid #0f0;transform:scaleX(-1);}</style></head><body><canvas id="debug-cvs" width="640" height="480"></canvas></body></html>`);
            debugWin.document.close();
            setTimeout(() => { if(debugWin && !debugWin.closed) { debugCanvas = debugWin.document.getElementById('debug-cvs'); debugCtx = debugCanvas.getContext('2d'); } }, 500);
        };

        function drawSkeleton(landmarks, ctx) {
            if(!ctx) return;
            ctx.lineWidth = 3; ctx.strokeStyle = '#00ff00'; ctx.fillStyle = '#ff0000';
            const c = (a, b) => { 
                ctx.beginPath(); 
                ctx.moveTo(landmarks[a].x * 640, landmarks[a].y * 480); 
                ctx.lineTo(landmarks[b].x * 640, landmarks[b].y * 480); 
                ctx.stroke(); 
            };
            c(0,1);c(1,2);c(2,3);c(3,4); c(0,5);c(5,6);c(6,7);c(7,8); c(0,9);c(9,10);c(10,11);c(11,12);
            c(0,13);c(13,14);c(14,15);c(15,16); c(0,17);c(17,18);c(18,19);c(19,20); c(5,9);c(9,13);c(13,17);
            for(let lm of landmarks) { ctx.beginPath(); ctx.arc(lm.x*640, lm.y*480, 4, 0, 2*Math.PI); ctx.fill(); }
        }

        // --- CONFIG ---
        const GRID_W = 128, GRID_H = 96;
        const CONFIG = {
            count: 20000, size: 0.06, shape: 'sphere', hue: 0.5, spinFriction: 0.95,
            appMode: 'VIEW', bloomStr: 1.5, useTexture: false, isHolo: false,
            shapes: ['sphere', 'cube', 'galaxy', 'dna'] // For V-gesture swap
        };

        const STATE = {
            pos: new THREE.Vector3(), vel: new THREE.Vector3(), rotVel: {x:0, y:0},
            handPos: new THREE.Vector3(), prevHandPos: new THREE.Vector3(), smoothHand: new THREE.Vector3(),
            lastDrawPos: new THREE.Vector3(),
            drawIndex: 0, isMouseDrawing: false, activeHandId: 0,
            scale: 1.0, entropy: 0.0, mode: 'IDLE', lastMode: 'IDLE',
            scatterOffset: new Float32Array(CONFIG.count * 3),
            originalColors: new Float32Array(CONFIG.count * 3),
            swipeCooldown: 0, handsDistance: 0
        };

        // --- THREE JS ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 8;
        const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene); composer.addPass(bloomPass);

        // --- PARTICLES ---
        function getTexture() {
            const c = document.createElement('canvas'); c.width=32; c.height=32;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(16,16,0,16,16,16);
            g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(0.4,'rgba(255,255,255,0.3)'); g.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle=g; ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(c);
        }

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.count * 3);
        const colors = new Float32Array(CONFIG.count * 3);
        const shapes = { sphere: [], galaxy: [], dna: [], cube: [], custom: [], holo: [] };
        const colorObj = new THREE.Color();

        for(let i=0; i<CONFIG.count; i++) {
            const p = Math.acos(-1 + (2*i)/CONFIG.count);
            const t = Math.sqrt(CONFIG.count * Math.PI) * p;
            shapes.sphere.push(3*Math.cos(t)*Math.sin(p), 3*Math.sin(t)*Math.sin(p), 3*Math.cos(p));
            
            const ang = i*0.05; const r = (i/CONFIG.count)*8;
            shapes.galaxy.push(r*Math.cos(ang), (Math.random()-0.5)*1 + Math.sin(r)*0.5, r*Math.sin(ang));

            const td = i * 0.1; const rad = 2;
            const x = Math.cos(td) * rad; const y = (i/CONFIG.count)*12 - 6; const z = Math.sin(td) * rad;
            shapes.dna.push(i%2==0?x:-x, y, i%2==0?z:-z);

            shapes.cube.push((Math.random()-0.5)*5, (Math.random()-0.5)*5, (Math.random()-0.5)*5);
            shapes.custom.push(9999,9999,9999);

            if (i < GRID_W * GRID_H) {
                const gx = (i % GRID_W) / GRID_W; const gy = Math.floor(i / GRID_W) / GRID_H;
                shapes.holo.push((gx - 0.5) * 12, -(gy - 0.5) * 9, 0);
            } else { shapes.holo.push(0, 0, 99999); }

            if (i < CONFIG.count / 2) colorObj.setHSL(0.5 + Math.random()*0.1, 1.0, 0.6); 
            else colorObj.setHSL(0.8 + Math.random()*0.1, 1.0, 0.6); 
            colors[i*3] = colorObj.r; colors[i*3+1] = colorObj.g; colors[i*3+2] = colorObj.b;

            STATE.scatterOffset[i*3] = (Math.random()-0.5)*30;
            STATE.scatterOffset[i*3+1] = (Math.random()-0.5)*30;
            STATE.scatterOffset[i*3+2] = (Math.random()-0.5)*30;
        }

        positions.set(shapes.sphere);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        const material = new THREE.PointsMaterial({ size: CONFIG.size, map: getTexture(), vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false, transparent: true });
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        const cursor = new THREE.Mesh(new THREE.RingGeometry(0.15, 0.2, 32), new THREE.MeshBasicMaterial({ color: 0xff00ff, side: THREE.DoubleSide, transparent: true, opacity: 0.8 }));
        scene.add(cursor); cursor.visible = false;

        // --- LOGIC ---
        const objLoader = new OBJLoader();
        const videoElement = document.getElementById('video-feed');
        const hiddenCanvas = document.createElement('canvas'); hiddenCanvas.width = GRID_W; hiddenCanvas.height = GRID_H;
        const hiddenCtx = hiddenCanvas.getContext('2d', { willReadFrequently: true });
        const raycaster = new THREE.Raycaster();
        const drawPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);

        window.addEventListener('load', () => {
            document.getElementById('start-btn').addEventListener('click', () => window.AudioSys.init());
            
            document.getElementById('obj-input').addEventListener('change', (e) => {
                const file = e.target.files[0]; if(!file) return;
                const reader = new FileReader();
                reader.onload = function(ev) {
                    const object = objLoader.parse(ev.target.result);
                    let verts = [];
                    object.traverse((child) => { if (child.isMesh) {
                        const pos = child.geometry.attributes.position;
                        child.geometry.computeBoundingSphere();
                        const scale = 6.0 / child.geometry.boundingSphere.radius;
                        const center = child.geometry.boundingSphere.center;
                        for(let k=0; k<pos.count; k++) verts.push((pos.getX(k)-center.x)*scale, (pos.getY(k)-center.y)*scale, (pos.getZ(k)-center.z)*scale);
                    }});
                    if(verts.length===0) return;
                    for(let i=0; i<CONFIG.count; i++) {
                        const r = Math.floor(Math.random()*(verts.length/3));
                        shapes.custom[i*3] = verts[r*3]; shapes.custom[i*3+1] = verts[r*3+1]; shapes.custom[i*3+2] = verts[r*3+2];
                    }
                    CONFIG.shape='custom'; CONFIG.isHolo=false; CONFIG.useTexture=false; setAppMode('VIEW');
                    updateUI("OBJ LOADED");
                };
                reader.readAsText(file);
            });

            document.getElementById('tex-input').addEventListener('change', e => {
                const f = e.target.files[0]; if(f) {
                    const r = new FileReader();
                    r.onload = ev => {
                        const img = new Image(); img.onload = () => {
                            const c = document.createElement('canvas'); c.width=img.width; c.height=img.height;
                            const ctx = c.getContext('2d'); ctx.drawImage(img,0,0);
                            const d = ctx.getImageData(0,0,img.width,img.height).data;
                            for(let i=0; i<CONFIG.count; i++) {
                                const p = Math.acos(-1 + (2*i)/CONFIG.count); const t = Math.sqrt(CONFIG.count*Math.PI)*p;
                                const u = (t%(2*Math.PI))/(2*Math.PI); const v = p/Math.PI;
                                const px = Math.floor(u*img.width); const py = Math.floor(v*img.height);
                                const idx = (py*img.width+px)*4;
                                STATE.originalColors[i*3] = d[idx]/255; STATE.originalColors[i*3+1] = d[idx+1]/255; STATE.originalColors[i*3+2] = d[idx+2]/255;
                            }
                            CONFIG.useTexture=true; CONFIG.isHolo=false; updateUI("TEXTURE APPLIED");
                        };
                        img.src=ev.target.result;
                    };
                    r.readAsDataURL(f);
                }
            });

            document.getElementById('bg-input').addEventListener('change', e => { if(e.target.files[0]) { const r = new FileReader(); r.onload=ev=>document.getElementById('bg-layer').style.backgroundImage=`url(${ev.target.result})`; r.readAsDataURL(e.target.files[0]); }});
            document.getElementById('btn-view').onclick = () => setAppMode('VIEW');
            document.getElementById('btn-draw').onclick = () => setAppMode('DRAW');
            document.getElementById('clear-btn').onclick = () => { STATE.drawIndex=0; for(let i=0; i<CONFIG.count*3; i++) shapes.custom[i]=99999; window.AudioSys.playTone(300,'triangle'); };
            
            const bs=document.getElementById('bloom-slider'); if(bs) bs.oninput=(e)=>{bloomPass.strength=parseFloat(e.target.value);};
            const ss=document.getElementById('size-slider'); if(ss) ss.oninput=(e)=>{CONFIG.size=parseFloat(e.target.value); material.size=CONFIG.size;};
            const fs=document.getElementById('fric-slider'); if(fs) fs.oninput=(e)=>{CONFIG.spinFriction=parseFloat(e.target.value);};
            document.getElementById('color-input').addEventListener('input', e=>{ const c=new THREE.Color(e.target.value); const hsl={}; c.getHSL(hsl); CONFIG.hue=hsl.h; CONFIG.useTexture=false;});

            document.querySelectorAll('.shape-btn').forEach(btn => {
                btn.onclick = () => {
                    document.querySelectorAll('.shape-btn').forEach(b=>b.classList.remove('active')); btn.classList.add('active');
                    const s = btn.dataset.shape;
                    if(s==='holo') { CONFIG.isHolo=true; CONFIG.shape='holo'; STATE.pos.set(0,0,0); particles.rotation.set(0,0,0); } 
                    else { CONFIG.isHolo=false; CONFIG.shape=s; }
                    setAppMode('VIEW'); window.AudioSys.playTone(600,'sine');
                };
            });
        });

        // --- CORE ---
        function setAppMode(mode) {
            CONFIG.appMode = mode;
            document.getElementById('btn-view').className = mode==='VIEW'?'mode-btn active':'mode-btn';
            document.getElementById('btn-draw').className = mode==='DRAW'?'mode-btn active':'mode-btn';
            document.getElementById('view-controls').style.display = mode==='VIEW'?'block':'none';
            document.getElementById('draw-controls').style.display = mode==='DRAW'?'block':'none';
            if(mode==='DRAW') { CONFIG.shape='custom'; CONFIG.isHolo=false; STATE.drawIndex=0; for(let i=0; i<CONFIG.count*3; i++) shapes.custom[i]=99999; STATE.pos.set(0,0,0); }
        }

        const uiText = document.getElementById('cinematic-mode');
        let uiTimeout;
        function updateUI(text) {
            if (text === STATE.lastMode) return;
            STATE.lastMode = text;
            uiText.innerText = text; uiText.style.opacity = 1;
            uiText.style.color = text==='DRAWING'?'#fff':'#0ff';
            clearTimeout(uiTimeout); uiTimeout = setTimeout(() => { uiText.style.opacity = 0; }, 1500);
        }

        // --- GESTURE RECOGNITION (V95 LOGIC) ---
        function analyzeHand(lm) {
            const d = (i1, i2) => Math.hypot(lm[i1].x - lm[i2].x, lm[i1].y - lm[i2].y);
            const index = lm[8].y < lm[6].y; 
            const middle = lm[12].y < lm[10].y;
            const ring = lm[16].y < lm[14].y;
            const pinky = lm[20].y < lm[18].y;
            const extended = [index, middle, ring, pinky].filter(Boolean).length;

            let gesture = 'UNKNOWN';
            if (extended === 0) gesture = 'FIST'; // Move
            else if (extended >= 4) gesture = 'PALM'; // Rotate
            else if (index && !middle && !ring && !pinky) gesture = 'INDEX'; // Draw
            else if (index && middle && !ring && !pinky) gesture = 'VICTORY'; // Swap Shape

            return { gesture, x: (1-lm[9].x-0.5)*20, y: (1-lm[9].y-0.5)*12, z: lm[9].z };
        }

        function animate() {
            requestAnimationFrame(animate);
            STATE.smoothHand.lerp(STATE.handPos, 0.2); // "Oily" smooth
            const posAttr = geometry.attributes.position;
            const colAttr = geometry.attributes.color;

            // --- PHYSICS ---
            if (STATE.mode === 'MOVE') {
                STATE.pos.lerp(STATE.smoothHand, 0.1);
            } else if (STATE.mode === 'ROTATE') {
                const dx = STATE.handPos.x - STATE.prevHandPos.x;
                const dy = STATE.handPos.y - STATE.prevHandPos.y;
                STATE.rotVel.y += dx * 0.3; STATE.rotVel.x -= dy * 0.3;
            } else if (STATE.mode === 'DUAL') {
                STATE.pos.lerp(STATE.smoothHand, 0.1);
            } else {
                STATE.pos.lerp(new THREE.Vector3(0,0,0), 0.05); // Return to center
            }
            // Friction
            STATE.rotVel.x *= CONFIG.spinFriction; STATE.rotVel.y *= CONFIG.spinFriction;
            particles.rotation.x += STATE.rotVel.x * 0.1; particles.rotation.y += STATE.rotVel.y * 0.1;
            particles.scale.setScalar(STATE.scale); particles.position.copy(STATE.pos);
            STATE.entropy *= 0.9; // Decay explosion

            // --- HOLOGRAM LOGIC ---
            if (CONFIG.isHolo && videoElement.readyState === 4) {
                hiddenCtx.drawImage(videoElement, 0, 0, GRID_W, GRID_H);
                const frame = hiddenCtx.getImageData(0, 0, GRID_W, GRID_H).data;
                const targetShape = shapes.holo;
                for(let i=0; i<CONFIG.count; i++) {
                    const ix = i * 3;
                    if (i >= GRID_W * GRID_H) { posAttr.array[ix+2]=99999; continue; }
                    const row = Math.floor(i/GRID_W); const col = i%GRID_W;
                    const pixelIdx = (row*GRID_W + (GRID_W-1-col))*4;
                    const br = (frame[pixelIdx] + frame[pixelIdx+1] + frame[pixelIdx+2]) / 765.0;
                    
                    let tx = targetShape[ix]; let ty = targetShape[ix+1]; let tz = br * 3.0; // Depth
                    
                    // Interaction
                    const dist = Math.hypot(tx - STATE.smoothHand.x, ty - STATE.smoothHand.y);
                    if(dist < 2.5) tz -= (2.5 - dist) * 2.0;

                    posAttr.array[ix] += (tx - posAttr.array[ix])*0.2;
                    posAttr.array[ix+1] += (ty - posAttr.array[ix+1])*0.2;
                    posAttr.array[ix+2] += (tz - posAttr.array[ix+2])*0.2;
                    colAttr.array[ix] = frame[pixelIdx]/255; colAttr.array[ix+1] = frame[pixelIdx+1]/255; colAttr.array[ix+2] = frame[pixelIdx+2]/255;
                }
                particles.rotation.set(0,0,0); STATE.pos.set(0,0,0);
            } 
            // --- STANDARD SHAPES ---
            else {
                const targetShape = shapes[CONFIG.shape] || shapes.sphere;
                const isDraw = STATE.mode === 'DRAW' || CONFIG.appMode === 'DRAW';
                
                // DRAW LOGIC (PERSISTENT TRAIL)
                if (isDraw) {
                    cursor.visible = true;
                    cursor.position.copy(STATE.isMouseDrawing ? STATE.mouseWorld : STATE.smoothHand);
                    
                    // Spawn particles
                    const spawn = 15;
                    const input = STATE.isMouseDrawing ? STATE.mouseWorld : STATE.smoothHand;
                    // Calc local pos inside container
                    const localPos = input.clone().sub(STATE.pos).divideScalar(STATE.scale);
                    // Apply inverse rotation approximation (simple version)
                    
                    for(let k=0; k<spawn; k++) {
                        const idx = (STATE.drawIndex + k) % CONFIG.count;
                        shapes.custom[idx*3] = localPos.x + (Math.random()-0.5)*0.2;
                        shapes.custom[idx*3+1] = localPos.y + (Math.random()-0.5)*0.2;
                        shapes.custom[idx*3+2] = localPos.z + (Math.random()-0.5)*0.2;
                    }
                    STATE.drawIndex = (STATE.drawIndex + spawn) % CONFIG.count;
                } else { cursor.visible = false; }

                for(let i=0; i<CONFIG.count; i++) {
                    const ix = i*3;
                    let tx, ty, tz;

                    // If part of drawing trail
                    if (CONFIG.appMode === 'DRAW' || (isDraw && i < STATE.drawIndex && i > (STATE.drawIndex - 2000 + CONFIG.count)%CONFIG.count)) {
                        tx = shapes.custom[ix]; ty = shapes.custom[ix+1]; tz = shapes.custom[ix+2];
                    } else {
                        tx = targetShape[ix]; ty = targetShape[ix+1]; tz = targetShape[ix+2];
                    }

                    if (STATE.entropy > 0.01) {
                        tx += STATE.scatterOffset[ix] * STATE.entropy * 5;
                        ty += STATE.scatterOffset[ix+1] * STATE.entropy * 5;
                        tz += STATE.scatterOffset[ix+2] * STATE.entropy * 5;
                    }

                    posAttr.array[ix] += (tx - posAttr.array[ix]) * 0.1;
                    posAttr.array[ix+1] += (ty - posAttr.array[ix+1]) * 0.1;
                    posAttr.array[ix+2] += (tz - posAttr.array[ix+2]) * 0.1;

                    // Colors
                    if (CONFIG.useTexture && !isDraw && !CONFIG.isHolo && CONFIG.shape !== 'custom') {
                        colAttr.array[ix] = STATE.originalColors[ix];
                        colAttr.array[ix+1] = STATE.originalColors[ix+1];
                        colAttr.array[ix+2] = STATE.originalColors[ix+2];
                    } else {
                        if (isDraw && Math.abs(posAttr.array[ix] - shapes.custom[ix]) < 0.5) {
                            colAttr.array[ix]=1; colAttr.array[ix+1]=1; colAttr.array[ix+2]=1;
                        } else {
                            const h = CONFIG.hue + (i/CONFIG.count)*0.1;
                            colorObj.setHSL(h, 1.0, 0.6);
                            colAttr.array[ix] = colorObj.r; colAttr.array[ix+1] = colorObj.g; colAttr.array[ix+2] = colorObj.b;
                        }
                    }
                }
            }
            posAttr.needsUpdate = true; colAttr.needsUpdate = true;
            composer.render();
        }

        // --- INPUTS ---
        function onResults(results) {
            document.getElementById('loader').style.display='none';
            if(debugWin && !debugWin.closed && debugCtx && results.image) {
                debugCtx.drawImage(results.image, 0, 0, 640, 480);
                if(results.multiHandLandmarks) for(let lm of results.multiHandLandmarks) drawSkeleton(lm, debugCtx);
            }

            const hands = results.multiHandLandmarks;
            const count = hands ? hands.length : 0;
            let newMode = 'IDLE';

            if (count === 2) {
                const h1 = analyzeHand(hands[0]); const h2 = analyzeHand(hands[1]);
                const p1 = new THREE.Vector3(h1.x, h1.y, 0); const p2 = new THREE.Vector3(h2.x, h2.y, 0);
                const dist = p1.distanceTo(p2);
                if (Math.abs(dist - STATE.handsDistance) > 0.5 && dist < 5) STATE.entropy = 1.0;
                STATE.handsDistance = dist; STATE.scale = Math.max(0.2, dist / 6.0);
                newMode = 'DUAL';
                STATE.handPos.lerp(p1.add(p2).multiplyScalar(0.5), 0.2);
            } else if (count === 1) {
                const h = analyzeHand(hands[0]);
                STATE.handPos.set(h.x, h.y, 0);
                
                if (h.gesture === 'FIST') newMode = 'MOVE';
                else if (h.gesture === 'PALM') newMode = 'ROTATE';
                else if (h.gesture === 'INDEX') newMode = 'DRAW';
                else if (h.gesture === 'VICTORY') {
                    newMode = 'SWIPE';
                    const dx = h.x - STATE.prevHandPos.x;
                    if (Math.abs(dx) > 1.0 && Date.now() > STATE.swipeCooldown) {
                        const idx = (CONFIG.shapes.indexOf(CONFIG.shape) + 1) % CONFIG.shapes.length;
                        CONFIG.shape = CONFIG.shapes[idx];
                        CONFIG.isHolo = false;
                        updateUI(CONFIG.shape.toUpperCase());
                        STATE.swipeCooldown = Date.now() + 500;
                        window.AudioSys.play(600, 'square');
                    }
                }
            }

            if(CONFIG.isHolo && newMode !== 'IDLE') updateUI("HOLO INTERACT");
            else updateUI(newMode);
            
            STATE.mode = newMode;
            STATE.prevHandPos.copy(STATE.handPos);
        }

        // --- MOUSE HANDLERS ---
        window.addEventListener('mousemove', e => {
            STATE.mouse.x = (e.clientX/window.innerWidth)*2-1; STATE.mouse.y = -(e.clientY/window.innerHeight)*2+1;
            raycaster.setFromCamera(STATE.mouse, camera); raycaster.ray.intersectPlane(drawPlane, STATE.mouseWorld);
        });
        window.addEventListener('mousedown', () => { if(CONFIG.appMode==='DRAW') STATE.isMouseDrawing=true; });
        window.addEventListener('mouseup', () => STATE.isMouseDrawing=false);
        window.addEventListener('resize', () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); });

        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}` });
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
        hands.onResults(onResults);
        const cam = new Camera(videoElement, { onFrame: async () => await hands.send({image: videoElement}), width: 640, height: 480 });
        cam.start();
        animate();
    </script>
</body>
</html>
