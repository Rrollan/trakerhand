<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CYBER-HAND V71: FIXED MESH</title>
    <style>
        /* –ë–ª–æ–∫–∏—Ä—É–µ–º —Å–∫—Ä–æ–ª–ª –∏ –∑—É–º –¥–ª—è –∂–µ—Å—Ç–æ–≤ */
        body { 
            margin: 0; overflow: hidden; background-color: #050505; 
            font-family: 'Segoe UI', monospace; color: white; 
            user-select: none; -webkit-user-select: none;
            touch-action: none; 
        }
        
        #bg-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; 
            background: radial-gradient(circle at center, #1a1a1a 0%, #000 100%);
        }

        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        #video-feed { 
            position: absolute; bottom: 20px; left: 20px; width: 120px; z-index: 2; 
            border-radius: 12px; border: 1px solid rgba(0, 255, 255, 0.3); 
            transform: scaleX(-1); opacity: 0.6; pointer-events: none;
        }
        
        #ui-panel { 
            position: absolute; top: 10px; right: 10px; width: 90%; max-width: 300px;
            padding: 15px; background: rgba(10, 10, 15, 0.90); 
            backdrop-filter: blur(20px); border-radius: 16px; 
            border: 1px solid rgba(0, 255, 255, 0.2); 
            z-index: 10; transition: transform 0.3s ease;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.1);
            max-height: 85vh; overflow-y: auto;
        }
        
        .header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px; margin-bottom: 15px; }
        h2 { margin: 0; font-size: 14px; color: #00ffff; letter-spacing: 2px; text-shadow: 0 0 10px rgba(0,255,255,0.5); }
        
        .control-row { margin-bottom: 15px; }
        .label { display: flex; justify-content: space-between; font-size: 10px; color: #aaa; margin-bottom: 5px; text-transform: uppercase; }
        
        input[type=range] { width: 100%; -webkit-appearance: none; background: #333; height: 3px; border-radius: 2px; outline: none; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; background: #00ffff; border-radius: 50%; cursor: pointer; box-shadow: 0 0 10px #00ffff; border: 2px solid #000;}
        
        .mode-switch { display: flex; gap: 5px; margin-bottom: 15px; background: #000; padding: 4px; border-radius: 8px; border: 1px solid #333; }
        .mode-btn { 
            flex: 1; padding: 10px; border: none; background: transparent; color: #666; 
            font-size: 10px; font-weight: bold; cursor: pointer; border-radius: 6px; transition: 0.2s; 
        }
        .mode-btn.active { background: #00ffff; color: #000; box-shadow: 0 0 15px rgba(0,255,255,0.4); }

        .file-upload {
            display: block; width: 100%; padding: 12px 0; text-align: center;
            background: rgba(0, 255, 255, 0.05); border: 1px dashed #00ffff;
            color: #00ffff; font-size: 10px; cursor: pointer; border-radius: 6px;
            transition: 0.2s; margin-bottom: 8px; box-sizing: border-box;
            text-shadow: 0 0 5px rgba(0,255,255,0.3);
        }
        .file-upload:hover { background: rgba(0, 255, 255, 0.15); box-shadow: 0 0 15px rgba(0,255,255,0.2); }
        input[type="file"] { display: none; }
        input[type="color"] { border: none; width: 100%; height: 30px; background: none; cursor: pointer; padding: 0;}

        .shape-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-top: 15px; }
        .shape-btn { background: #111; border: 1px solid #333; color: #ccc; padding: 10px; border-radius: 4px; cursor: pointer; font-size: 10px; transition: 0.2s; text-transform: uppercase;}
        .shape-btn:hover { border-color: #fff; }
        .shape-btn.active { border-color: #00ffff; color: #00ffff; box-shadow: inset 0 0 10px rgba(0,255,255,0.2); }

        #clear-btn { width: 100%; padding: 12px; background: #300; color: #f55; margin-top: 5px; border: 1px solid #600; border-radius: 6px; cursor: pointer;}
        
        #mode-disp { text-align: center; color: #00ffff; font-weight: bold; font-size: 12px; margin-top: 15px; letter-spacing: 1px; padding: 8px; background: rgba(0,255,255,0.05); border-radius: 4px; border: 1px solid rgba(0,255,255,0.1);}

        #loader { position: absolute; top:0; left:0; width:100%; height:100%; background:#000; z-index:99; display:flex; flex-direction:column; justify-content:center; align-items:center; color:#00ffff; font-size:14px; transition: opacity 0.5s; text-align: center; }
        
        #start-screen { position: absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.95); z-index: 999; display:flex; justify-content:center; align-items:center; cursor:pointer; flex-direction: column;}
        #start-btn { font-size: 20px; border: 2px solid #00ffff; color: #00ffff; padding: 15px 40px; border-radius: 50px; background: transparent; transition: 0.3s; box-shadow: 0 0 20px rgba(0,255,255,0.2); text-transform: uppercase; letter-spacing: 2px;}
        #start-btn:hover { background: #00ffff; color: #000; box-shadow: 0 0 50px rgba(0,255,255,0.8); }
        
        #ui-hint { position: absolute; top: 20px; right: 20px; color: rgba(255,255,255,0.3); font-size: 12px; display: none; pointer-events: none; z-index: 5; }
    </style>

    <!-- –ò–ú–ü–û–†–¢–´ –ë–ò–ë–õ–ò–û–¢–ï–ö -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/examples/jsm/loaders/OBJLoader.js": "https://unpkg.com/three@0.128.0/examples/jsm/loaders/OBJLoader.js",
                "three/examples/jsm/postprocessing/EffectComposer.js": "https://unpkg.com/three@0.128.0/examples/jsm/postprocessing/EffectComposer.js",
                "three/examples/jsm/postprocessing/RenderPass.js": "https://unpkg.com/three@0.128.0/examples/jsm/postprocessing/RenderPass.js",
                "three/examples/jsm/postprocessing/UnrealBloomPass.js": "https://unpkg.com/three@0.128.0/examples/jsm/postprocessing/UnrealBloomPass.js",
                "three/examples/jsm/postprocessing/ShaderPass.js": "https://unpkg.com/three@0.128.0/examples/jsm/postprocessing/ShaderPass.js",
                "three/examples/jsm/shaders/CopyShader.js": "https://unpkg.com/three@0.128.0/examples/jsm/shaders/CopyShader.js",
                "three/examples/jsm/shaders/LuminosityHighPassShader.js": "https://unpkg.com/three@0.128.0/examples/jsm/shaders/LuminosityHighPassShader.js"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js"></script>
</head>
<body>

    <div id="bg-layer"></div>
    <div id="loader"><div>–ó–ê–ì–†–£–ó–ö–ê –Ø–î–†–ê...</div><div style="font-size:10px; color:#666; margin-top:5px;">–†–∞–∑—Ä–µ—à–∏—Ç–µ –¥–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ</div></div>

    <div id="start-screen">
        <button id="start-btn">INITIATE SYSTEM</button>
        <div style="margin-top:20px; color:#555; font-size:11px;">BLOOM | OBJ | TEXTURE | MOBILE</div>
    </div>

    <div id="ui-hint">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</div>

    <div id="ui-panel">
        <div class="header">
            <h2>CYBER-HAND V71</h2>
            <button onclick="document.getElementById('ui-panel').style.transform = 'translateX(120%)'; document.getElementById('ui-hint').style.display='block';" style="background:none; border:none; color:#0ff; cursor:pointer; font-size:16px;">‚úï</button>
        </div>

        <div class="mode-switch">
            <button class="mode-btn active" id="btn-view">üëÅ –ü–†–û–°–ú–û–¢–†</button>
            <button class="mode-btn" id="btn-draw">üñå –†–ò–°–û–í–ê–ù–ò–ï</button>
        </div>

        <div id="view-controls">
            <label class="file-upload">
                üì• –ó–ê–ì–†–£–ó–ò–¢–¨ 3D –ú–û–î–ï–õ–¨ (.OBJ)
                <input type="file" id="obj-input" accept=".obj">
            </label>
            
            <label class="file-upload" style="border-color: #ff00ff; color: #ff00ff;">
                üñº –ó–ê–ì–†–£–ó–ò–¢–¨ –¢–ï–ö–°–¢–£–†–£ (–§–û–¢–û)
                <input type="file" id="tex-input" accept="image/*">
            </label>

            <label class="file-upload" style="border-color: #888; color: #888;">
                üåÜ –ó–ê–ì–†–£–ó–ò–¢–¨ –§–û–ù
                <input type="file" id="bg-input" accept="image/*">
            </label>

            <div class="control-row">
                <div class="label"><span>–¶–≤–µ—Ç</span></div>
                <input type="color" id="color-input" value="#00ffff">
            </div>

            <div class="control-row">
                <div class="label"><span>–°–≤–µ—á–µ–Ω–∏–µ (Bloom)</span><span id="val-bloom">1.5</span></div>
                <input type="range" id="bloom-slider" min="0" max="3" step="0.1" value="1.5">
            </div>

            <div class="control-row">
                <div class="label"><span>–†–∞–∑–º–µ—Ä —á–∞—Å—Ç–∏—Ü</span><span id="val-size">0.06</span></div>
                <input type="range" id="size-slider" min="0.01" max="0.2" step="0.01" value="0.06">
            </div>

            <div class="control-row">
                <div class="label"><span>–ò–Ω–µ—Ä—Ü–∏—è</span><span id="val-fric">0.95</span></div>
                <input type="range" id="fric-slider" min="0.80" max="0.99" step="0.01" value="0.95">
            </div>

            <div class="shape-grid">
                <button class="shape-btn active" data-shape="sphere">–°—Ñ–µ—Ä–∞</button>
                <button class="shape-btn" data-shape="galaxy">–ì–∞–ª–∞–∫—Ç–∏–∫–∞</button>
                <button class="shape-btn" data-shape="dna">–î–ù–ö</button>
                <button class="shape-btn" data-shape="cube">–ö—É–±</button>
            </div>
        </div>

        <div id="draw-controls" style="display:none;">
            <div style="text-align:center; font-size:11px; color:#fff; margin-bottom:10px; background: rgba(0,255,255,0.1); padding: 10px; border-radius: 6px;">
                1. <b>–ü–∞–ª–µ—Ü/–ú—ã—à—å/–ö—É–ª–∞–∫</b> ‚Äî –†–∏—Å–æ–≤–∞—Ç—å<br>
                2. –ñ–µ—Å—Ç <b>"–û–ö"</b> ‚Äî –°–æ—Ö—Ä–∞–Ω–∏—Ç—å
            </div>
            <button id="clear-btn">–û–ß–ò–°–¢–ò–¢–¨</button>
        </div>

        <div id="mode-disp">SYSTEM READY</div>
    </div>

    <video id="video-feed" playsinline webkit-playsinline></video>
    <div id="canvas-container" onclick="document.getElementById('ui-panel').style.transform = 'translateX(0)'; document.getElementById('ui-hint').style.display='none';"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader.js';
        import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';

        // --- AUDIO SYSTEM ---
        window.AudioSys = {
            ctx: null, masterGain: null, active: false,
            init: function() {
                if(this.active) return;
                const AC = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AC();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.2;
                this.masterGain.connect(this.ctx.destination);
                this.active = true;
                document.getElementById('start-screen').style.display = 'none';
                if(this.ctx.state === 'suspended') this.ctx.resume();
            },
            playTone: function(freq, type='sine') {
                if(!this.active) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                osc.type = type; osc.frequency.setValueAtTime(freq, t);
                const g = this.ctx.createGain();
                g.gain.setValueAtTime(0.1, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.2);
                osc.connect(g); g.connect(this.masterGain);
                osc.start(); osc.stop(t+0.2);
            }
        };

        document.getElementById('start-btn').addEventListener('click', () => window.AudioSys.init());

        // --- CONFIG ---
        const CONFIG = {
            count: 20000, // –£–≤–µ–ª–∏—á–∏–ª –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —á–∞—Å—Ç–∏—Ü –¥–ª—è –ª—É—á—à–µ–π –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏–∏ –º–æ–¥–µ–ª–µ–π
            size: 0.05,
            shape: 'sphere',
            hue: 0.5,
            spinFriction: 0.95,
            appMode: 'VIEW',
            bloomStr: 1.5,
            useTexture: false
        };

        const STATE = {
            pos: new THREE.Vector3(), vel: new THREE.Vector3(), rotVel: {x:0, y:0},
            hand1: new THREE.Vector3(), hand2: new THREE.Vector3(),
            prevHand: new THREE.Vector3(), smoothHand: new THREE.Vector3(),
            mouse: new THREE.Vector2(), mouseWorld: new THREE.Vector3(), lastDrawPos: new THREE.Vector3(),
            drawIndex: 0, isMouseDrawing: false, isHandDrawing: false, activeHandId: 0,
            scale: 1.0, entropy: 0.0, mode: 'IDLE',
            scatterOffset: new Float32Array(CONFIG.count * 3),
            originalColors: new Float32Array(CONFIG.count * 3),
            resizeBaseY: 0, resizeBaseS: 1.0
        };

        // --- THREE JS INIT ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 8;
        
        const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- POST PROCESSING (BLOOM) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.strength = CONFIG.bloomStr;
        bloomPass.radius = 0.5;
        bloomPass.threshold = 0;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- PARTICLES ---
        function getTexture() {
            const c = document.createElement('canvas'); c.width=32; c.height=32;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(16,16,0,16,16,16);
            g.addColorStop(0,'rgba(255,255,255,1)');
            g.addColorStop(0.4,'rgba(255,255,255,0.3)');
            g.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle=g; ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(c);
        }

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.count * 3);
        const colors = new Float32Array(CONFIG.count * 3);
        const shapes = { sphere: [], galaxy: [], dna: [], cube: [], custom: [] };
        const colorObj = new THREE.Color();

        for(let i=0; i<CONFIG.count; i++) {
            // SPHERE
            const phi = Math.acos(-1 + (2*i)/CONFIG.count);
            const theta = Math.sqrt(CONFIG.count * Math.PI) * phi;
            shapes.sphere.push(3*Math.cos(theta)*Math.sin(phi), 3*Math.sin(theta)*Math.sin(phi), 3*Math.cos(phi));
            
            // GALAXY
            const ang = i*0.05; const r = (i/CONFIG.count)*8;
            shapes.galaxy.push(r*Math.cos(ang), (Math.random()-0.5)*1 + Math.sin(r)*0.5, r*Math.sin(ang));

            // DNA
            const t = i * 0.1;
            const radius = 2;
            const x = Math.cos(t) * radius;
            const y = (i / CONFIG.count) * 12 - 6;
            const z = Math.sin(t) * radius;
            if (i % 2 === 0) shapes.dna.push(x, y, z); else shapes.dna.push(-x, y, -z);

            // CUBE
            shapes.cube.push((Math.random()-0.5)*5, (Math.random()-0.5)*5, (Math.random()-0.5)*5);
            shapes.custom.push(9999,9999,9999);

            // COLORS
            if (i < CONFIG.count / 2) colorObj.setHSL(0.5 + Math.random()*0.1, 1.0, 0.6); 
            else colorObj.setHSL(0.8 + Math.random()*0.1, 1.0, 0.6); 
            colors[i*3] = colorObj.r; colors[i*3+1] = colorObj.g; colors[i*3+2] = colorObj.b;

            STATE.scatterOffset[i*3] = (Math.random()-0.5)*30;
            STATE.scatterOffset[i*3+1] = (Math.random()-0.5)*30;
            STATE.scatterOffset[i*3+2] = (Math.random()-0.5)*30;
        }

        positions.set(shapes.sphere);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({ 
            size: CONFIG.size, map: getTexture(), vertexColors: true, 
            blending: THREE.AdditiveBlending, depthWrite: false, transparent: true 
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        const cursor = new THREE.Mesh(
            new THREE.RingGeometry(0.15, 0.2, 32),
            new THREE.MeshBasicMaterial({ color: 0xff00ff, side: THREE.DoubleSide, transparent: true, opacity: 0.8 })
        );
        scene.add(cursor); cursor.visible = false;

        // --- FIXED OBJ LOADER (RANDOM SAMPLING) ---
        const objLoader = new OBJLoader();
        document.getElementById('obj-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if(!file) return;
            const reader = new FileReader();
            reader.onload = function(ev) {
                const contents = ev.target.result;
                const object = objLoader.parse(contents);
                let modelVertices = [];
                object.traverse((child) => {
                    if (child.isMesh) {
                        const pos = child.geometry.attributes.position;
                        child.geometry.computeBoundingSphere();
                        const center = child.geometry.boundingSphere.center;
                        const radius = child.geometry.boundingSphere.radius;
                        const scale = 6.0 / radius;
                        for(let k=0; k < pos.count; k++) {
                            const vx = (pos.getX(k) - center.x) * scale;
                            const vy = (pos.getY(k) - center.y) * scale;
                            const vz = (pos.getZ(k) - center.z) * scale;
                            modelVertices.push(vx, vy, vz);
                        }
                    }
                });
                if(modelVertices.length === 0) { alert("Bad Model"); return; }
                
                // --- –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: RANDOM SAMPLING ---
                // –í–º–µ—Å—Ç–æ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–≥–æ –ø–µ—Ä–µ–±–æ—Ä–∞, –±–µ—Ä–µ–º —Å–ª—É—á–∞–π–Ω—ã–µ —Ç–æ—á–∫–∏
                const totalVertices = modelVertices.length / 3;
                
                for(let i=0; i<CONFIG.count; i++) {
                    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–ª—É—á–∞–π–Ω—ã–π –∏–Ω–¥–µ–∫—Å –≤–µ—Ä—à–∏–Ω—ã
                    const randIdx = Math.floor(Math.random() * totalVertices);
                    
                    shapes.custom[i*3] = modelVertices[randIdx*3];
                    shapes.custom[i*3+1] = modelVertices[randIdx*3+1];
                    shapes.custom[i*3+2] = modelVertices[randIdx*3+2];
                }

                CONFIG.shape = 'custom';
                CONFIG.useTexture = false;
                CONFIG.appMode = 'VIEW';
                document.querySelectorAll('.shape-btn').forEach(b=>b.classList.remove('active'));
                window.AudioSys.playTone(400, 'square');
            };
            reader.readAsText(file);
        });

        // --- TEXTURE LOADER ---
        const mapCanvas = document.createElement('canvas'); const mapCtx = mapCanvas.getContext('2d');
        document.getElementById('tex-input').addEventListener('change', e => {
            const f = e.target.files[0];
            if(f) {
                const reader = new FileReader();
                reader.onload = ev => {
                    const img = new Image();
                    img.onload = () => {
                        mapCanvas.width = img.width; mapCanvas.height = img.height;
                        mapCtx.drawImage(img,0,0);
                        const data = mapCtx.getImageData(0,0,img.width,img.height).data;
                        for(let i=0; i<CONFIG.count; i++) {
                            const phi = Math.acos(-1 + (2*i)/CONFIG.count);
                            const theta = Math.sqrt(CONFIG.count * Math.PI) * phi;
                            let u = (theta % (2*Math.PI))/(2*Math.PI);
                            let v = phi / Math.PI;
                            const px = Math.floor(u*img.width); const py = Math.floor(v*img.height);
                            const idx = (py*img.width+px)*4;
                            STATE.originalColors[i*3] = data[idx]/255;
                            STATE.originalColors[i*3+1] = data[idx+1]/255;
                            STATE.originalColors[i*3+2] = data[idx+2]/255;
                        }
                        CONFIG.useTexture = true;
                        bloomPass.strength = 0.8; 
                        document.getElementById('bloom-slider').value = 0.8;
                        document.getElementById('val-bloom').innerText = 0.8;
                        window.AudioSys.playTone(500, 'sine');
                    };
                    img.src = ev.target.result;
                };
                reader.readAsDataURL(f);
            }
        });

        // --- UI HANDLERS ---
        const raycaster = new THREE.Raycaster();
        const drawPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);

        document.getElementById('btn-view').onclick = () => setAppMode('VIEW');
        document.getElementById('btn-draw').onclick = () => setAppMode('DRAW');
        document.getElementById('clear-btn').onclick = () => {
            STATE.drawIndex = 0;
            for(let i=0; i<CONFIG.count*3; i++) shapes.custom[i] = 99999;
            window.AudioSys.playTone(300, 'triangle');
        };

        document.getElementById('bloom-slider').oninput = (e) => { 
            bloomPass.strength = parseFloat(e.target.value); 
            document.getElementById('val-bloom').innerText = e.target.value; 
        };
        document.getElementById('size-slider').oninput = (e) => { 
            CONFIG.size = parseFloat(e.target.value); material.size = CONFIG.size; 
            document.getElementById('val-size').innerText = e.target.value; 
        };
        document.getElementById('fric-slider').oninput = (e) => { 
            CONFIG.spinFriction = parseFloat(e.target.value); 
            document.getElementById('val-fric').innerText = e.target.value; 
        };
        document.getElementById('color-input').addEventListener('input', e => {
            const c = new THREE.Color(e.target.value);
            const hsl = {}; c.getHSL(hsl);
            CONFIG.hue = hsl.h;
            CONFIG.useTexture = false;
        });
        document.getElementById('bg-input').addEventListener('change', e => {
            const f = e.target.files[0];
            if(f) { const r = new FileReader(); r.onload=ev=>document.getElementById('bg-layer').style.backgroundImage=`url(${ev.target.result})`; r.readAsDataURL(f); }
        });

        document.querySelectorAll('.shape-btn').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.shape-btn').forEach(b=>b.classList.remove('active'));
                btn.classList.add('active');
                CONFIG.shape = btn.dataset.shape;
                setAppMode('VIEW');
                window.AudioSys.playTone(600, 'sine');
            };
        });

        function setAppMode(mode) {
            CONFIG.appMode = mode;
            document.getElementById('btn-view').className = mode === 'VIEW' ? 'mode-btn active' : 'mode-btn';
            document.getElementById('btn-draw').className = mode === 'DRAW' ? 'mode-btn active' : 'mode-btn';
            document.getElementById('view-controls').style.display = mode === 'VIEW' ? 'block' : 'none';
            document.getElementById('draw-controls').style.display = mode === 'DRAW' ? 'block' : 'none';
            
            if(mode === 'DRAW') {
                CONFIG.shape = 'custom';
                STATE.drawIndex = 0;
                for(let i=0; i<CONFIG.count*3; i++) shapes.custom[i] = 99999;
                STATE.pos.set(0,0,0); STATE.vel.set(0,0,0);
            }
        }

        // --- INPUT HANDLING ---
        function updatePointer(x, y) {
            STATE.mouse.x = (x / window.innerWidth) * 2 - 1;
            STATE.mouse.y = -(y / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(STATE.mouse, camera);
            raycaster.ray.intersectPlane(drawPlane, STATE.mouseWorld);
        }

        window.addEventListener('mousemove', e => updatePointer(e.clientX, e.clientY));
        window.addEventListener('mousedown', () => { if(CONFIG.appMode==='DRAW') STATE.isMouseDrawing=true; });
        window.addEventListener('mouseup', () => STATE.isMouseDrawing=false);

        window.addEventListener('touchstart', e => {
            if(e.target.closest('#ui-panel') || e.target.closest('#start-screen')) return;
            if(CONFIG.appMode === 'DRAW') {
                STATE.isMouseDrawing = true; 
                updatePointer(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, {passive: false});

        window.addEventListener('touchmove', e => {
            if(e.target.closest('#ui-panel')) return;
            if(STATE.isMouseDrawing) {
                updatePointer(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, {passive: false});
        window.addEventListener('touchend', () => STATE.isMouseDrawing = false);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            STATE.smoothHand.lerp(STATE.hand1, 0.2);
            const targetShape = shapes[CONFIG.shape];
            const posAttr = geometry.attributes.position;
            const colAttr = geometry.attributes.color;

            if(CONFIG.appMode === 'DRAW') {
                cursor.visible = true;
                let inputPos = STATE.isMouseDrawing ? STATE.mouseWorld : (STATE.isHandDrawing ? STATE.smoothHand : null);
                
                if(STATE.isHandDrawing || STATE.activeHandId===1) cursor.position.copy(STATE.smoothHand);
                else cursor.position.copy(STATE.mouseWorld);

                if(inputPos) {
                    cursor.material.color.setHex(0xff00ff);
                    if(STATE.activeHandId) cursor.rotation.z += 0.2;
                    
                    const dist = inputPos.distanceTo(STATE.lastDrawPos);
                    if(dist > 0.05 || STATE.drawIndex === 0) {
                        const steps = Math.min(20, Math.ceil(dist/0.05));
                        for(let s=0; s<=steps; s++) {
                            if(STATE.drawIndex >= CONFIG.count) break;
                            const t = s/steps;
                            const v = new THREE.Vector3().lerpVectors(STATE.lastDrawPos, inputPos, t);
                            const idx = STATE.drawIndex*3;
                            shapes.custom[idx]=v.x; shapes.custom[idx+1]=v.y; shapes.custom[idx+2]=v.z;
                            STATE.drawIndex++;
                        }
                        STATE.lastDrawPos.copy(inputPos);
                    }
                } else {
                    cursor.material.color.setHex(0x00ffff);
                    cursor.rotation.z = 0;
                    if(STATE.activeHandId) STATE.lastDrawPos.copy(STATE.smoothHand);
                    else STATE.lastDrawPos.copy(STATE.mouseWorld);
                }
            } else {
                cursor.visible = false;
            }

            for(let i=0; i<CONFIG.count; i++) {
                const ix = i*3;
                let tx = targetShape[ix]; let ty = targetShape[ix+1]; let tz = targetShape[ix+2];

                if(STATE.mode === 'GRAB') { tx*=0.8; ty*=0.8; tz*=0.8; } 

                if(STATE.entropy > 0.01) {
                    tx += STATE.scatterOffset[ix] * STATE.entropy;
                    ty += STATE.scatterOffset[ix+1] * STATE.entropy;
                    tz += STATE.scatterOffset[ix+2] * STATE.entropy;
                }

                posAttr.array[ix] += (tx - posAttr.array[ix]) * 0.08;
                posAttr.array[ix+1] += (ty - posAttr.array[ix+1]) * 0.08;
                posAttr.array[ix+2] += (tz - posAttr.array[ix+2]) * 0.08;

                if(CONFIG.useTexture) {
                    colAttr.array[ix] = STATE.originalColors[ix];
                    colAttr.array[ix+1] = STATE.originalColors[ix+1];
                    colAttr.array[ix+2] = STATE.originalColors[ix+2];
                } else {
                    if(CONFIG.appMode === 'DRAW' && i < STATE.drawIndex) {
                        colAttr.array[ix]=1; colAttr.array[ix+1]=1; colAttr.array[ix+2]=1;
                    } else {
                        let h = CONFIG.hue + (i/CONFIG.count)*0.1;
                        colorObj.setHSL(h, 1.0, 0.6);
                        colAttr.array[ix] = colorObj.r; colAttr.array[ix+1] = colorObj.g; colAttr.array[ix+2] = colorObj.b;
                    }
                }
            }
            posAttr.needsUpdate = true;
            colAttr.needsUpdate = true;

            if(CONFIG.appMode === 'VIEW') {
                const activePos = (STATE.activeHandId === 2) ? STATE.hand2 : STATE.smoothHand;

                if (STATE.mode === 'GRAB') {
                    STATE.pos.lerp(activePos, 0.1);
                    STATE.rotVel.x *= 0.9; STATE.rotVel.y *= 0.9;
                } else if (STATE.mode === 'ROTATE') {
                    const dX = activePos.x - STATE.prevHand.x;
                    const dY = activePos.y - STATE.prevHand.y;
                    STATE.rotVel.y += dX * 0.3;
                    STATE.rotVel.x -= dY * 0.3;
                } else if (STATE.mode === 'DUAL HANDS') {
                    const mid = new THREE.Vector3().addVectors(STATE.hand1, STATE.hand2).multiplyScalar(0.5);
                    STATE.pos.lerp(mid, 0.1);
                    const dx = STATE.hand2.x - STATE.hand1.x;
                    const dy = STATE.hand2.y - STATE.hand1.y;
                    particles.rotation.z += (Math.atan2(dy, dx) - particles.rotation.z) * 0.1;
                } else {
                    STATE.pos.add(STATE.vel);
                    STATE.vel.multiplyScalar(CONFIG.spinFriction);
                    if(Math.abs(STATE.pos.x)>15) STATE.vel.x*=-1;
                    if(Math.abs(STATE.pos.y)>10) STATE.vel.y*=-1;
                    particles.rotation.y += 0.001;
                }
                
                particles.rotation.x += STATE.rotVel.x * 0.1;
                particles.rotation.y += STATE.rotVel.y * 0.1;
                STATE.rotVel.x *= CONFIG.spinFriction; STATE.rotVel.y *= CONFIG.spinFriction;

                STATE.scale += (STATE.scale - STATE.scale) * 0.1; 
                particles.scale.setScalar(STATE.scale);
                particles.position.copy(STATE.pos);
                STATE.prevHand.copy(activePos);
            } else {
                particles.position.set(0,0,0);
                particles.rotation.set(0,0,0);
                particles.scale.setScalar(1);
            }

            composer.render();
        }

        // --- MEDIAPIPE LOGIC ---
        const uiMode = document.getElementById('mode-disp');
        const loader = document.getElementById('loader');

        function onResults(results) {
            if(loader) loader.style.display = 'none';
            const count = results.multiHandLandmarks ? results.multiHandLandmarks.length : 0;
            
            let h1=null, x1=0, y1=0;
            if(count>0) {
                const lm1 = results.multiHandLandmarks[0];
                h1 = analyze(lm1);
                x1 = (1 - lm1[9].x - 0.5) * 25; y1 = (1 - lm1[9].y - 0.5) * 15;
            }
            if(count>1) {
                const lm2 = results.multiHandLandmarks[1];
                const x2 = (1 - lm2[9].x - 0.5) * 25; const y2 = (1 - lm2[9].y - 0.5) * 15;
                STATE.hand2.set(x2,y2,0);
            }

            if(CONFIG.appMode === 'DRAW') {
                if(h1 && h1.isPinch) {
                    setAppMode('VIEW');
                    window.AudioSys.playTone(600);
                    return;
                }
                if(h1 && h1.isGrab) {
                    STATE.activeHandId = 1; STATE.hand1.set(x1,y1,0); STATE.isHandDrawing=true;
                    updateMode('DRAWING (FIST)');
                } else {
                    STATE.isHandDrawing=false;
                    if(h1) { STATE.hand1.set(x1,y1,0); STATE.activeHandId=1; }
                    updateMode('CURSOR');
                }
                return;
            }

            if(count===2) {
                 STATE.hand1.set(x1, y1, 0);
                 const dist = STATE.hand1.distanceTo(STATE.hand2);
                 STATE.entropy = (dist < 5) ? 0 : Math.min(1.0, (dist-5)/10);
                 updateMode('DUAL HANDS');
                 return;
            } else { STATE.entropy = 0; }

            if(count>0) {
                STATE.activeHandId = 1; STATE.hand1.set(x1,y1,0);
                if(h1.isGrab) { updateMode('GRAB'); return; }
                if(h1.isPinch) {
                    if(STATE.mode!=='RESIZE') { STATE.resizeBaseY=y1; STATE.resizeBaseS=STATE.scale; }
                    STATE.scale = Math.max(0.3, Math.min(3.0, STATE.resizeBaseS + (y1-STATE.resizeBaseY)*0.3));
                    updateMode('RESIZE');
                    return;
                }
                if(h1.isOpen) { updateMode('ROTATE'); return; }
            }
            updateMode('IDLE');
        }

        function analyze(lm) {
            const isIndexUp = lm[8].y < lm[6].y;
            const isMiddleUp = lm[12].y < lm[10].y;
            const isRingUp = lm[16].y < lm[14].y;
            const isPinkyUp = lm[20].y < lm[18].y;
            const pinchDist = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
            const fingers = [isIndexUp, isMiddleUp, isRingUp, isPinkyUp].filter(Boolean).length;
            return { isGrab: fingers<=1, isPinch: pinchDist<0.05 && isMiddleUp, isOpen: fingers>=4 };
        }

        function updateMode(m) {
            if(STATE.mode === m) return;
            STATE.mode = m;
            uiMode.innerText = m;
            const ru = { 'GRAB': '–ö–£–õ–ê–ö (–¢–ê–©–ò–¢–¨)', 'ROTATE': '–õ–ê–î–û–ù–¨ (–í–†–ê–©–ï–ù–ò–ï)', 'RESIZE': '–ñ–ï–°–¢ –û–ö (–†–ê–ó–ú–ï–†)', 'DUAL HANDS': '–î–í–ï –†–£–ö–ò', 'IDLE': '–û–ñ–ò–î–ê–ù–ò–ï', 'DRAWING (FIST)': '–†–ò–°–£–ï–ú (–ö–£–õ–ê–ö)', 'CURSOR': '–ö–£–†–°–û–†' };
            uiMode.innerText = ru[m] || m;
            if(m==='GRAB') window.AudioSys.playTone(150, 'sawtooth');
            if(m==='RESIZE') window.AudioSys.playTone(400, 'sine');
        }

        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}` });
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        hands.onResults(onResults);
        
        const cam = new Camera(document.getElementById('video-feed'), {
            onFrame: async () => await hands.send({image: document.getElementById('video-feed')}),
            width: 640, height: 480
        });
        cam.start();
        animate();
    </script>
</body>
</html>
