<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>CYBER-HAND V18: STABLE CORE</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', monospace; color: white; user-select: none; }
        
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; background: radial-gradient(circle at center, #111 0%, #000 100%); }
        
        #video-feed { position: absolute; bottom: 20px; left: 20px; width: 180px; height: 135px; z-index: 2; border-radius: 12px; border: 1px solid rgba(255, 255, 255, 0.3); transform: scaleX(-1); opacity: 0.5; transition: opacity 1s; object-fit: cover; }
        
        #ui-panel { position: absolute; top: 20px; right: 20px; width: 280px; padding: 20px; background: rgba(10, 10, 10, 0.85); backdrop-filter: blur(12px); border-radius: 16px; border: 1px solid rgba(255, 255, 255, 0.1); z-index: 10; }
        h2 { margin: 0 0 15px 0; font-size: 14px; text-transform: uppercase; color: #00ffff; border-bottom: 1px solid #333; padding-bottom: 10px; letter-spacing: 1px; }
        
        .grid-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 15px; }
        button { background: rgba(255, 255, 255, 0.05); border: 1px solid #444; color: #aaa; padding: 10px; border-radius: 6px; cursor: pointer; transition: 0.2s; font-size: 11px; text-transform: uppercase; }
        button:hover { background: #333; color: #fff; }
        button.active { background: rgba(0, 255, 255, 0.2); border-color: #00ffff; color: #00ffff; }
        
        .status-box { font-size: 11px; color: #888; line-height: 1.6; }
        .key { color: #fff; font-weight: bold; }
        .dual { color: #ff00ff; font-weight: bold; }
        #mode-display { font-size: 14px; color: #00ffff; font-weight: bold; margin-top: 10px; text-align: center; background: rgba(0, 255, 255, 0.1); padding: 8px; border-radius: 4px;}

        #start-screen { position: absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index: 999; display:flex; justify-content:center; align-items:center; cursor:pointer; flex-direction: column;}
        #start-btn { font-size: 20px; border: 2px solid #00ffff; color: #00ffff; padding: 15px 40px; border-radius: 50px; text-transform: uppercase; letter-spacing: 2px; transition: 0.3s; }
        #start-btn:hover { background: #00ffff; color: #000; box-shadow: 0 0 30px rgba(0,255,255,0.5); }
        
        #error-log { position: absolute; top: 10px; left: 10px; color: #ff3333; z-index: 1000; font-size: 12px; pointer-events: none; }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js"></script>
</head>
<body>

    <div id="start-screen" onclick="initSystem()">
        <div id="start-btn">START SYSTEM</div>
        <div style="margin-top:15px; color:#666; font-size:12px;">Enables Audio & Physics Engine</div>
    </div>

    <div id="error-log"></div>

    <div id="ui-panel">
        <h2>Control V18</h2>
        <div class="grid-buttons" id="shape-buttons">
            <button onclick="setShape('sphere')" class="active">Sphere</button>
            <button onclick="setShape('galaxy')">Galaxy</button>
            <button onclick="setShape('heart')">Heart</button>
            <button onclick="setShape('cube')">Cube</button>
        </div>
        <div class="status-box">
            <div><span class="dual">üëê Two Hands:</span> ROTATE & SCATTER</div>
            <div><span class="key">üëã One Hand:</span> SPIN (Inertia)</div>
            <div><span class="key">‚úä Fist:</span> GRAB & PASS</div>
            <div><span class="key">‚òùÔ∏è Index:</span> MOVE</div>
            <div><span class="key">‚úåÔ∏è Victory:</span> RESIZE</div>
            <div id="mode-display">IDLE</div>
            <div id="debug-info" style="text-align:center; margin-top:5px;">Waiting for camera...</div>
        </div>
    </div>

    <video id="video-feed" playsinline></video>
    <div id="canvas-container"></div>

    <script>
        // --- ERROR HANDLING ---
        window.onerror = function(msg, url, line) {
            document.getElementById('error-log').innerHTML += `<br>Error: ${msg}`;
        };

        // --- AUDIO ENGINE (Simple & Soft) ---
        const AudioSys = {
            ctx: null, active: false,
            init: function() {
                if(this.active) return;
                const AC = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AC();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.3;
                this.masterGain.connect(this.ctx.destination);
                this.active = true;
                document.getElementById('start-screen').style.display = 'none';
            },
            playTone: function(freq, type='sine', dur=0.1) {
                if(!this.active) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, t);
                const g = this.ctx.createGain();
                g.gain.setValueAtTime(0.1, t);
                g.gain.linearRampToValueAtTime(0, t+dur);
                osc.connect(g); g.connect(this.masterGain);
                osc.start(); osc.stop(t+dur);
            }
        };

        function initSystem() { AudioSys.init(); }

        // --- CONFIG ---
        const CONFIG = { count: 8000, size: 0.12, shape: 'sphere' };
        
        // --- STATE (The Brain) ---
        const STATE = {
            pos: new THREE.Vector3(0,0,0),    
            vel: new THREE.Vector3(0,0,0),    
            momentum: new THREE.Vector3(0,0,0),
            
            // Interaction
            handPos1: new THREE.Vector3(0,0,0), 
            handPos2: new THREE.Vector3(0,0,0),
            prevHandPos1: new THREE.Vector3(0,0,0),
            
            rotVel: {x:0, y:0},
            scale: 1.0,
            entropy: 0.0,
            mode: 'IDLE',
            
            scatterOffset: new Float32Array(CONFIG.count * 3)
        };

        // --- THREE.JS ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 8;
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Texture
        function getTexture() {
            const c = document.createElement('canvas'); c.width=64; c.height=64;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(32,32,0,32,32,32);
            g.addColorStop(0,'rgba(255,255,255,1)');
            g.addColorStop(0.4,'rgba(100,200,255,0.5)');
            g.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle=g; ctx.fillRect(0,0,64,64);
            return new THREE.CanvasTexture(c);
        }

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.count * 3);
        const colors = new Float32Array(CONFIG.count * 3);
        const shapes = { sphere: [], galaxy: [], heart: [], cube: [] };
        const c3 = new THREE.Color();

        // Init Data
        for(let i=0; i<CONFIG.count; i++) {
            // Sphere
            const phi = Math.acos(-1 + (2*i)/CONFIG.count);
            const theta = Math.sqrt(CONFIG.count * Math.PI) * phi;
            shapes.sphere.push(2.5*Math.cos(theta)*Math.sin(phi), 2.5*Math.sin(theta)*Math.sin(phi), 2.5*Math.cos(phi));
            
            // Galaxy
            const angle = i*0.1; const r = (i/CONFIG.count)*6;
            shapes.galaxy.push((r*Math.cos(angle)), (Math.random()-0.5)*0.5, (r*Math.sin(angle)));
            
            // Heart
            const t = (i/CONFIG.count)*Math.PI*2;
            const hx = 16*Math.pow(Math.sin(t),3);
            const hy = 13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
            shapes.heart.push(hx*0.15, hy*0.15, (Math.random()-0.5));
            shapes.cube.push((Math.random()-0.5)*4, (Math.random()-0.5)*4, (Math.random()-0.5)*4);

            c3.setHSL(i/CONFIG.count, 0.8, 0.6);
            colors[i*3]=c3.r; colors[i*3+1]=c3.g; colors[i*3+2]=c3.b;
            STATE.scatterOffset[i*3] = (Math.random()-0.5)*15;
            STATE.scatterOffset[i*3+1] = (Math.random()-0.5)*15;
            STATE.scatterOffset[i*3+2] = (Math.random()-0.5)*15;
        }

        positions.set(shapes.sphere);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: CONFIG.size, map: getTexture(), vertexColors: true,
            blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 1.0
        });
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- ANIMATION ---
        window.setShape = (n) => {
            CONFIG.shape = n;
            document.querySelectorAll('#shape-buttons button').forEach(b=>b.classList.remove('active'));
            event.target.classList.add('active');
        }

        function animate() {
            requestAnimationFrame(animate);

            // NAN PROTECTION (Safety check)
            if (isNaN(STATE.pos.x)) STATE.pos.set(0,0,0);
            if (isNaN(STATE.rotVel.x)) STATE.rotVel = {x:0, y:0};

            const targetShape = shapes[CONFIG.shape];
            const posAttr = geometry.attributes.position;
            const colAttr = geometry.attributes.color;
            const time = Date.now() * 0.001;

            for(let i=0; i<CONFIG.count; i++) {
                const ix = i*3;
                let tx = targetShape[ix]; let ty = targetShape[ix+1]; let tz = targetShape[ix+2];

                if(STATE.mode === 'GRAB') { tx *= 0.8; ty *= 0.8; tz *= 0.8; tx+=(Math.random()-0.5)*0.2; }

                // Entropy Mixing
                if (STATE.entropy > 0.01) {
                    tx = tx*(1-STATE.entropy) + STATE.scatterOffset[ix]*STATE.entropy;
                    ty = ty*(1-STATE.entropy) + STATE.scatterOffset[ix+1]*STATE.entropy;
                    tz = tz*(1-STATE.entropy) + STATE.scatterOffset[ix+2]*STATE.entropy;
                }

                posAttr.array[ix] += (tx - posAttr.array[ix]) * 0.1;
                posAttr.array[ix+1] += (ty - posAttr.array[ix+1]) * 0.1;
                posAttr.array[ix+2] += (tz - posAttr.array[ix+2]) * 0.1;

                // Color
                let h=(i/CONFIG.count+time*0.1)%1; let s=0.8; let l=0.6;
                if(STATE.mode === 'GRAB') { h=0.55; s=0.2; l=1.0; }
                else if(STATE.mode === 'DUAL') { h=0.7 - (STATE.entropy*0.4); s=1.0; l=0.6 + STATE.entropy*0.4; }
                else if(STATE.mode === 'MOVE') { h=0.6; s=0.9; l=0.7; }
                else if(STATE.mode === 'ROTATE') { h=0.1; s=1.0; l=0.6; }
                
                c3.setHSL(h,s,l);
                colAttr.array[ix]=c3.r; colAttr.array[ix+1]=c3.g; colAttr.array[ix+2]=c3.b;
            }
            posAttr.needsUpdate = true; colAttr.needsUpdate = true;

            // PHYSICS LOGIC
            if (STATE.mode === 'MOVE' || STATE.mode === 'GRAB') {
                const delta = new THREE.Vector3().subVectors(STATE.handPos1, STATE.prevHandPos1);
                STATE.momentum.lerp(delta, 0.2);
            }

            if (STATE.mode === 'MOVE') {
                STATE.pos.lerp(STATE.handPos1, 0.2);
                STATE.rotVel.x *= 0.9; STATE.rotVel.y *= 0.9; // Stop spin
            } 
            else if (STATE.mode === 'GRAB') {
                STATE.pos.lerp(STATE.handPos1, 0.4); // Snappy
                STATE.rotVel.x *= 0.9; STATE.rotVel.y *= 0.9;
            }
            else if (STATE.mode === 'DUAL') {
                // Midpoint
                const mid = new THREE.Vector3().addVectors(STATE.handPos1, STATE.handPos2).multiplyScalar(0.5);
                STATE.pos.lerp(mid, 0.1);
                
                // Rotation Steering
                const dx = STATE.handPos2.x - STATE.handPos1.x;
                const dy = STATE.handPos2.y - STATE.handPos1.y;
                const angle = Math.atan2(dy, dx);
                particles.rotation.z += (angle - particles.rotation.z) * 0.1;
                
                STATE.vel.set(0,0,0);
            }
            else if (STATE.mode === 'DRIFT' || STATE.mode === 'ROTATE') {
                // Inertia Drift
                STATE.pos.add(STATE.vel);
                STATE.vel.multiplyScalar(0.98); 
                
                // Rotational Inertia
                particles.rotation.x += STATE.rotVel.x;
                particles.rotation.y += STATE.rotVel.y;
                STATE.rotVel.x *= 0.98;
                STATE.rotVel.y *= 0.98;

                // Bounce
                if(STATE.pos.x > 16 || STATE.pos.x < -16) STATE.vel.x *= -0.7;
                if(STATE.pos.y > 10 || STATE.pos.y < -10) STATE.vel.y *= -0.7;
            } 
            else if (STATE.mode === 'RESIZE') {
                let s = 1.0 + (STATE.handPos1.y * 0.4);
                STATE.scale += (s - STATE.scale) * 0.1;
            }
            else {
                // Idle Rotation
                particles.rotation.y += 0.002;
            }

            particles.position.copy(STATE.pos);
            particles.scale.setScalar(STATE.scale);
            
            STATE.prevHandPos1.copy(STATE.handPos1);
            renderer.render(scene, camera);
        }

        // --- TRACKING ---
        const uiMode = document.getElementById('mode-display');
        const uiDebug = document.getElementById('debug-info');
        const videoElement = document.getElementById('video-feed');

        function onResults(results) {
            const handsCount = results.multiHandLandmarks ? results.multiHandLandmarks.length : 0;
            uiDebug.innerText = `Hands Detected: ${handsCount}`;

            // Hand 1 (Always exists if count > 0)
            let h1 = null, x1=0, y1=0;
            if (handsCount > 0) {
                const lm1 = results.multiHandLandmarks[0];
                h1 = analyzeHand(lm1);
                x1 = (1 - lm1[9].x - 0.5) * 20; 
                y1 = (1 - lm1[9].y - 0.5) * 12;
            }

            // Hand 2
            let h2 = null, x2=0, y2=0;
            if (handsCount > 1) {
                const lm2 = results.multiHandLandmarks[1];
                h2 = analyzeHand(lm2);
                x2 = (1 - lm2[9].x - 0.5) * 20; 
                y2 = (1 - lm2[9].y - 0.5) * 12;
                STATE.handPos2.set(x2, y2, 0);
            }

            // --- LOGIC TREE ---

            // 1. DUAL HANDS
            if (handsCount === 2 && h1.fingers >= 3 && h2.fingers >= 3) {
                STATE.handPos1.set(x1, y1, 0);
                // Calculate Entropy based on distance
                const dist = STATE.handPos1.distanceTo(STATE.handPos2);
                // Safe < 6, Chaos > 6
                STATE.entropy = (dist < 6.0) ? 0 : Math.min(1.0, (dist - 6.0)/8.0);
                
                updateMode('DUAL');
                return;
            } else {
                STATE.entropy = 0; // Reset chaos if not dual
            }

            // 2. PASSING (Juggling Logic)
            if (handsCount === 2) {
                // If Hand 2 grabs, it takes control
                if (h2.isGrab) {
                    STATE.handPos1.set(x2, y2, 0); // Active follows Hand 2
                    if(STATE.mode !== 'GRAB') AudioSys.playTone(150, 'sine');
                    updateMode('GRAB');
                    return;
                }
            }

            if (handsCount > 0) {
                STATE.handPos1.set(x1, y1, 0);

                if (h1.isGrab) {
                    if(STATE.mode !== 'GRAB') AudioSys.playTone(150, 'sine');
                    updateMode('GRAB');
                    return;
                }
                
                if (h1.isVictory) { updateMode('RESIZE'); return; }
                if (h1.isIndexOnly) { updateMode('MOVE'); return; }

                // Open Palm -> SPIN or DRIFT
                if (h1.fingers >= 4) {
                    // Check hand speed for Throw vs Spin
                    const speed = STATE.handPos1.distanceTo(STATE.prevHandPos1);
                    
                    if (STATE.mode === 'GRAB' || STATE.mode === 'MOVE') {
                        // Throwing
                        launchDrift();
                    } else if (speed > 0.5) {
                        // Fast movement while open = Spin up
                        STATE.rotVel.x += (STATE.handPos1.y - STATE.prevHandPos1.y) * 0.2;
                        STATE.rotVel.y += (STATE.handPos1.x - STATE.prevHandPos1.x) * 0.2;
                        updateMode('ROTATE');
                    } else {
                        // Just hovering
                        if (STATE.vel.length() > 0.1) updateMode('DRIFT'); // Keep drifting
                        else updateMode('ROTATE');
                    }
                    return;
                }
            }

            // No hands? Keep drifting
            if (STATE.mode !== 'DRIFT' && STATE.mode !== 'IDLE') {
                if (STATE.mode === 'ROTATE') {/* keep spinning */}
                else launchDrift();
            }
        }

        function analyzeHand(lm) {
            const isIndexUp = lm[8].y < lm[6].y;
            const isMiddleUp = lm[12].y < lm[10].y;
            const isRingUp = lm[16].y < lm[14].y;
            const isPinkyUp = lm[20].y < lm[18].y;
            const isThumbOpen = Math.hypot(lm[4].x - lm[17].x, lm[4].y - lm[17].y) > 0.25;
            
            let fingers = [isIndexUp, isMiddleUp, isRingUp, isPinkyUp].filter(Boolean).length;
            if(isThumbOpen) fingers++;

            const isGrab = (fingers <= 1 && !isThumbOpen);
            const isVictory = (isIndexUp && isMiddleUp && !isRingUp && !isPinkyUp);
            const isIndexOnly = (isIndexUp && !isMiddleUp);

            return { fingers, thumbOpen: isThumbOpen, isGrab, isVictory, isIndexOnly };
        }

        function launchDrift() {
            if(STATE.mode === 'DRIFT') return;
            updateMode('DRIFT');
            STATE.vel.copy(STATE.momentum).multiplyScalar(2.5);
            if(STATE.vel.length() > 0.1) AudioSys.playTone(300, 'triangle', 0.2);
        }

        function updateMode(m) {
            if(STATE.mode === m) return;
            STATE.mode = m;
            uiMode.innerText = m;
            if(m==='GRAB') uiMode.style.color = 'white';
            else if(m==='DUAL') uiMode.style.color = '#ff00ff';
            else if(m==='ROTATE') uiMode.style.color = 'gold';
            else uiMode.style.color = '#00ffff';
        }

        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}` });
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        
        try {
            hands.onResults(onResults);
            const cam = new Camera(videoElement, { onFrame: async () => await hands.send({image: videoElement}), width: 640, height: 480 });
            cam.start();
        } catch(e) {
            document.getElementById('error-log').innerHTML = "Cam Error: " + e.message;
        }

        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        animate();
    </script>
</body>
</html>
