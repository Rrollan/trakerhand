<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CYBER-HAND V60: NEON GOD</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', monospace; color: white; user-select: none; }
        
        #bg-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; 
            background: radial-gradient(circle at center, #1a1a1a 0%, #000 100%);
        }

        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        #video-feed { 
            position: absolute; bottom: 20px; left: 20px; width: 160px; z-index: 2; 
            border-radius: 12px; border: 1px solid rgba(0, 255, 255, 0.3); 
            transform: scaleX(-1); opacity: 0.6; 
        }
        
        #ui-panel { 
            position: absolute; top: 20px; right: 20px; width: 300px; 
            padding: 20px; background: rgba(10, 10, 15, 0.90); 
            backdrop-filter: blur(20px); border-radius: 16px; 
            border: 1px solid rgba(0, 255, 255, 0.2); 
            z-index: 10; transition: transform 0.3s ease;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.1);
            max-height: 90vh; overflow-y: auto;
        }
        
        .header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px; margin-bottom: 15px; }
        h2 { margin: 0; font-size: 14px; color: #00ffff; letter-spacing: 2px; text-shadow: 0 0 10px rgba(0,255,255,0.5); }
        
        .control-row { margin-bottom: 15px; }
        .label { display: flex; justify-content: space-between; font-size: 10px; color: #aaa; margin-bottom: 5px; text-transform: uppercase; }
        
        input[type=range] { width: 100%; -webkit-appearance: none; background: #333; height: 3px; border-radius: 2px; outline: none; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 12px; height: 12px; background: #00ffff; border-radius: 50%; cursor: pointer; box-shadow: 0 0 10px #00ffff; }
        
        .mode-switch { display: flex; gap: 5px; margin-bottom: 15px; background: #000; padding: 4px; border-radius: 8px; border: 1px solid #333; }
        .mode-btn { 
            flex: 1; padding: 8px; border: none; background: transparent; color: #666; 
            font-size: 10px; font-weight: bold; cursor: pointer; border-radius: 6px; transition: 0.2s; 
        }
        .mode-btn.active { background: #00ffff; color: #000; box-shadow: 0 0 15px rgba(0,255,255,0.4); }

        .file-upload {
            display: block; width: 100%; padding: 12px 0; text-align: center;
            background: rgba(0, 255, 255, 0.05); border: 1px dashed #00ffff;
            color: #00ffff; font-size: 10px; cursor: pointer; border-radius: 6px;
            transition: 0.2s; margin-bottom: 8px; box-sizing: border-box;
            text-shadow: 0 0 5px rgba(0,255,255,0.3);
        }
        .file-upload:hover { background: rgba(0, 255, 255, 0.15); box-shadow: 0 0 15px rgba(0,255,255,0.2); }
        input[type="file"] { display: none; }

        .shape-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-top: 15px; }
        .shape-btn { background: #111; border: 1px solid #333; color: #ccc; padding: 8px; border-radius: 4px; cursor: pointer; font-size: 10px; transition: 0.2s; text-transform: uppercase;}
        .shape-btn:hover { border-color: #fff; }
        .shape-btn.active { border-color: #00ffff; color: #00ffff; box-shadow: inset 0 0 10px rgba(0,255,255,0.2); }

        #clear-btn { width: 100%; padding: 10px; background: #300; color: #f55; margin-top: 5px; border: 1px solid #600; border-radius: 6px; cursor: pointer;}
        
        #mode-disp { text-align: center; color: #00ffff; font-weight: bold; font-size: 12px; margin-top: 15px; letter-spacing: 1px; padding: 8px; background: rgba(0,255,255,0.05); border-radius: 4px; border: 1px solid rgba(0,255,255,0.1);}

        #loader { position: absolute; top:0; left:0; width:100%; height:100%; background:#000; z-index:99; display:flex; flex-direction:column; justify-content:center; align-items:center; color:#00ffff; font-size:14px; transition: opacity 0.5s; }
        
        #start-screen { position: absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.95); z-index: 999; display:flex; justify-content:center; align-items:center; cursor:pointer; flex-direction: column;}
        #start-btn { font-size: 20px; border: 2px solid #00ffff; color: #00ffff; padding: 15px 40px; border-radius: 50px; background: transparent; transition: 0.3s; box-shadow: 0 0 20px rgba(0,255,255,0.2); text-transform: uppercase; letter-spacing: 2px;}
        #start-btn:hover { background: #00ffff; color: #000; box-shadow: 0 0 50px rgba(0,255,255,0.8); }
    </style>

    <!-- –ò–°–ü–û–õ–¨–ó–£–ï–ú –ú–û–î–£–õ–ò –î–õ–Ø –ë–ò–ë–õ–ò–û–¢–ï–ö (–°–û–í–†–ï–ú–ï–ù–ù–´–ô –ü–û–î–•–û–î) -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/examples/jsm/loaders/OBJLoader.js": "https://unpkg.com/three@0.128.0/examples/jsm/loaders/OBJLoader.js",
                "three/examples/jsm/postprocessing/EffectComposer.js": "https://unpkg.com/three@0.128.0/examples/jsm/postprocessing/EffectComposer.js",
                "three/examples/jsm/postprocessing/RenderPass.js": "https://unpkg.com/three@0.128.0/examples/jsm/postprocessing/RenderPass.js",
                "three/examples/jsm/postprocessing/UnrealBloomPass.js": "https://unpkg.com/three@0.128.0/examples/jsm/postprocessing/UnrealBloomPass.js",
                "three/examples/jsm/postprocessing/ShaderPass.js": "https://unpkg.com/three@0.128.0/examples/jsm/postprocessing/ShaderPass.js",
                "three/examples/jsm/shaders/CopyShader.js": "https://unpkg.com/three@0.128.0/examples/jsm/shaders/CopyShader.js",
                "three/examples/jsm/shaders/LuminosityHighPassShader.js": "https://unpkg.com/three@0.128.0/examples/jsm/shaders/LuminosityHighPassShader.js"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js"></script>
</head>
<body>

    <div id="bg-layer"></div>
    <div id="loader"><div>–ó–ê–ì–†–£–ó–ö–ê –Ø–î–†–ê...</div></div>

    <div id="start-screen">
        <button id="start-btn">INITIATE SYSTEM</button>
        <div style="margin-top:20px; color:#555; font-size:11px;">BLOOM ENGINE | OBJ LOADER | HAND TRACKING</div>
    </div>

    <div id="ui-panel">
        <div class="header">
            <h2>CYBER-HAND V60</h2>
            <button onclick="document.getElementById('ui-panel').style.display='none'" style="background:none; border:none; color:#0ff; cursor:pointer;">[-]</button>
        </div>

        <div class="mode-switch">
            <button class="mode-btn active" id="btn-view">üëÅ –ü–†–û–°–ú–û–¢–†</button>
            <button class="mode-btn" id="btn-draw">üñå –†–ò–°–û–í–ê–ù–ò–ï</button>
        </div>

        <div id="view-controls">
            <!-- –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø: –ó–ê–ì–†–£–ó–ö–ê 3D –ú–û–î–ï–õ–ò -->
            <label class="file-upload">
                üì• –ó–ê–ì–†–£–ó–ò–¢–¨ 3D –ú–û–î–ï–õ–¨ (.OBJ)
                <input type="file" id="obj-input" accept=".obj">
            </label>

            <div class="control-row">
                <div class="label"><span>–°–≤–µ—á–µ–Ω–∏–µ (Bloom)</span><span id="val-bloom">1.5</span></div>
                <input type="range" id="bloom-slider" min="0" max="3" step="0.1" value="1.5">
            </div>

            <div class="control-row">
                <div class="label"><span>–†–∞–∑–º–µ—Ä —á–∞—Å—Ç–∏—Ü</span><span id="val-size">0.06</span></div>
                <input type="range" id="size-slider" min="0.01" max="0.2" step="0.01" value="0.06">
            </div>

            <div class="control-row">
                <div class="label"><span>–ò–Ω–µ—Ä—Ü–∏—è</span><span id="val-fric">0.95</span></div>
                <input type="range" id="fric-slider" min="0.80" max="0.99" step="0.01" value="0.95">
            </div>

            <div class="shape-grid">
                <button class="shape-btn active" data-shape="sphere">–°—Ñ–µ—Ä–∞</button>
                <button class="shape-btn" data-shape="galaxy">–ì–∞–ª–∞–∫—Ç–∏–∫–∞</button>
                <button class="shape-btn" data-shape="dna">–î–ù–ö</button>
                <button class="shape-btn" data-shape="cube">–ö—É–±</button>
            </div>
        </div>

        <div id="draw-controls" style="display:none;">
            <div style="text-align:center; font-size:11px; color:#fff; margin-bottom:10px; background: rgba(0,255,255,0.1); padding: 10px; border-radius: 6px;">
                –ñ–µ—Å—Ç <b>"–û–ö"</b> —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç —Ä–∏—Å—É–Ω–æ–∫
            </div>
            <button id="clear-btn">–û–ß–ò–°–¢–ò–¢–¨</button>
        </div>

        <div id="mode-disp">SYSTEM READY</div>
    </div>

    <video id="video-feed" playsinline></video>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader.js';
        import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';

        // --- AUDIO ---
        const AudioSys = {
            ctx: null, masterGain: null, active: false,
            init: function() {
                if(this.active) return;
                const AC = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AC();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.2;
                this.masterGain.connect(this.ctx.destination);
                this.active = true;
                document.getElementById('start-screen').style.display = 'none';
            },
            playTone: function(freq, type='sine') {
                if(!this.active) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                osc.type = type; osc.frequency.setValueAtTime(freq, t);
                const g = this.ctx.createGain();
                g.gain.setValueAtTime(0.1, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.2);
                osc.connect(g); g.connect(this.masterGain);
                osc.start(); osc.stop(t+0.2);
            }
        };

        document.getElementById('start-btn').addEventListener('click', () => AudioSys.init());

        // --- CONFIG ---
        const CONFIG = {
            count: 20000, // –ë–æ–ª—å—à–µ —á–∞—Å—Ç–∏—Ü –¥–ª—è –∫—Ä—É—Ç–æ—Å—Ç–∏
            size: 0.06,
            shape: 'sphere',
            spinFriction: 0.95,
            appMode: 'VIEW',
            bloomStr: 1.5
        };

        const STATE = {
            pos: new THREE.Vector3(), vel: new THREE.Vector3(), rotVel: {x:0, y:0},
            hand1: new THREE.Vector3(), hand2: new THREE.Vector3(),
            prevHand: new THREE.Vector3(), smoothHand: new THREE.Vector3(),
            mouse: new THREE.Vector2(), mouseWorld: new THREE.Vector3(), lastDrawPos: new THREE.Vector3(),
            drawIndex: 0, isMouseDrawing: false, isHandDrawing: false, activeHandId: 0,
            scale: 1.0, entropy: 0.0, mode: 'IDLE',
            scatterOffset: new Float32Array(CONFIG.count * 3),
            resizeBaseY: 0, resizeBaseS: 1.0
        };

        // --- THREE JS INIT ---
        const scene = new THREE.Scene();
        // –¢—É–º–∞–Ω –¥–ª—è –≥–ª—É–±–∏–Ω—ã
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 8;
        
        const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false }); // Antialias off for bloom perf
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio); // Sharpness
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- POST PROCESSING (BLOOM) ---
        const renderScene = new RenderPass(scene, camera);
        
        // Resolution, Strength, Radius, Threshold
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.strength = CONFIG.bloomStr;
        bloomPass.radius = 0.5;
        bloomPass.threshold = 0;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- PARTICLES ---
        function getTexture() {
            const c = document.createElement('canvas'); c.width=32; c.height=32;
            const ctx = c.getContext('2d');
            // –ë–æ–ª–µ–µ –∂–µ—Å—Ç–∫–∏–π –≥—Ä–∞–¥–∏–µ–Ω—Ç –¥–ª—è –Ω–µ–æ–Ω–æ–≤–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞
            const g = ctx.createRadialGradient(16,16,0,16,16,16);
            g.addColorStop(0,'rgba(255,255,255,1)');
            g.addColorStop(0.4,'rgba(255,255,255,0.3)');
            g.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle=g; ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(c);
        }

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.count * 3);
        const colors = new Float32Array(CONFIG.count * 3);
        const shapes = { sphere: [], galaxy: [], dna: [], cube: [], custom: [] };
        
        // Generate Shapes
        const colorObj = new THREE.Color();
        for(let i=0; i<CONFIG.count; i++) {
            // SPHERE
            const phi = Math.acos(-1 + (2*i)/CONFIG.count);
            const theta = Math.sqrt(CONFIG.count * Math.PI) * phi;
            shapes.sphere.push(3*Math.cos(theta)*Math.sin(phi), 3*Math.sin(theta)*Math.sin(phi), 3*Math.cos(phi));
            
            // GALAXY
            const ang = i*0.05; const r = (i/CONFIG.count)*8;
            shapes.galaxy.push(r*Math.cos(ang), (Math.random()-0.5)*1 + Math.sin(r)*0.5, r*Math.sin(ang));

            // DNA
            const t = i * 0.1;
            const radius = 2;
            const x = Math.cos(t) * radius;
            const y = (i / CONFIG.count) * 12 - 6;
            const z = Math.sin(t) * radius;
            // –î–≤–æ–π–Ω–∞—è —Å–ø–∏—Ä–∞–ª—å
            if (i % 2 === 0) shapes.dna.push(x, y, z);
            else shapes.dna.push(-x, y, -z);

            // CUBE
            shapes.cube.push((Math.random()-0.5)*5, (Math.random()-0.5)*5, (Math.random()-0.5)*5);
            
            // CUSTOM Placeholder
            shapes.custom.push(9999,9999,9999);

            // COLORS (Cyberpunk Palette: Cyan & Magenta)
            if (i < CONFIG.count / 2) colorObj.setHSL(0.5 + Math.random()*0.1, 1.0, 0.6); // Cyan
            else colorObj.setHSL(0.8 + Math.random()*0.1, 1.0, 0.6); // Magenta
            
            colors[i*3] = colorObj.r; colors[i*3+1] = colorObj.g; colors[i*3+2] = colorObj.b;

            STATE.scatterOffset[i*3] = (Math.random()-0.5)*30;
            STATE.scatterOffset[i*3+1] = (Math.random()-0.5)*30;
            STATE.scatterOffset[i*3+2] = (Math.random()-0.5)*30;
        }

        positions.set(shapes.sphere);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({ 
            size: CONFIG.size, 
            map: getTexture(), 
            vertexColors: true, 
            blending: THREE.AdditiveBlending, 
            depthWrite: false, 
            transparent: true 
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // Cursor
        const cursor = new THREE.Mesh(
            new THREE.RingGeometry(0.15, 0.2, 32),
            new THREE.MeshBasicMaterial({ color: 0xff00ff, side: THREE.DoubleSide, transparent: true, opacity: 0.8 })
        );
        scene.add(cursor); cursor.visible = false;

        // --- OBJ LOADER LOGIC ---
        const objLoader = new OBJLoader();
        document.getElementById('obj-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if(!file) return;

            const reader = new FileReader();
            reader.onload = function(ev) {
                const contents = ev.target.result;
                const object = objLoader.parse(contents); // –°–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥

                // –ò–∑–≤–ª–µ–∫–∞–µ–º –≤–µ—Ä—à–∏–Ω—ã –∏–∑ –º–æ–¥–µ–ª–∏
                let modelVertices = [];
                object.traverse((child) => {
                    if (child.isMesh) {
                        const pos = child.geometry.attributes.position;
                        // –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
                        child.geometry.computeBoundingSphere();
                        const center = child.geometry.boundingSphere.center;
                        const radius = child.geometry.boundingSphere.radius;
                        
                        const scale = 6.0 / radius; // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º —Ä–∞–∑–º–µ—Ä –ø–æ–¥ –Ω–∞—à—É —Å—Ü–µ–Ω—É

                        for(let k=0; k < pos.count; k++) {
                            const vx = (pos.getX(k) - center.x) * scale;
                            const vy = (pos.getY(k) - center.y) * scale;
                            const vz = (pos.getZ(k) - center.z) * scale;
                            modelVertices.push(vx, vy, vz);
                        }
                    }
                });

                if(modelVertices.length === 0) { alert("–ú–æ–¥–µ–ª—å –ø—É—Å—Ç–∞ –∏–ª–∏ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è"); return; }

                // –ó–∞–ø–æ–ª–Ω—è–µ–º –º–∞—Å—Å–∏–≤ —á–∞—Å—Ç–∏—Ü (—Å—ç–º–ø–ª–∏–Ω–≥)
                for(let i=0; i<CONFIG.count; i++) {
                    const idx = i % (modelVertices.length / 3);
                    shapes.custom[i*3] = modelVertices[idx*3];
                    shapes.custom[i*3+1] = modelVertices[idx*3+1];
                    shapes.custom[i*3+2] = modelVertices[idx*3+2];
                }

                CONFIG.shape = 'custom';
                CONFIG.appMode = 'VIEW';
                // –û–±–Ω–æ–≤–ª—è–µ–º UI
                document.querySelectorAll('.shape-btn').forEach(b=>b.classList.remove('active'));
                AudioSys.playTone(400, 'square');
            };
            reader.readAsText(file);
        });


        // --- UI HANDLERS (Manual attachment because of module scope) ---
        const raycaster = new THREE.Raycaster();
        const drawPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);

        // Buttons
        document.getElementById('btn-view').onclick = () => setAppMode('VIEW');
        document.getElementById('btn-draw').onclick = () => setAppMode('DRAW');
        document.getElementById('clear-btn').onclick = () => {
            STATE.drawIndex = 0;
            for(let i=0; i<CONFIG.count*3; i++) shapes.custom[i] = 99999;
            AudioSys.playTone(300, 'triangle');
        };

        // Sliders
        document.getElementById('bloom-slider').oninput = (e) => { 
            bloomPass.strength = parseFloat(e.target.value); 
            document.getElementById('val-bloom').innerText = e.target.value; 
        };
        document.getElementById('size-slider').oninput = (e) => { 
            CONFIG.size = parseFloat(e.target.value); material.size = CONFIG.size; 
            document.getElementById('val-size').innerText = e.target.value; 
        };
        document.getElementById('fric-slider').oninput = (e) => { 
            CONFIG.spinFriction = parseFloat(e.target.value); 
            document.getElementById('val-fric').innerText = e.target.value; 
        };

        // Shapes
        document.querySelectorAll('.shape-btn').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.shape-btn').forEach(b=>b.classList.remove('active'));
                btn.classList.add('active');
                CONFIG.shape = btn.dataset.shape;
                setAppMode('VIEW');
                AudioSys.playTone(600, 'sine');
            };
        });

        function setAppMode(mode) {
            CONFIG.appMode = mode;
            document.getElementById('btn-view').className = mode === 'VIEW' ? 'mode-btn active' : 'mode-btn';
            document.getElementById('btn-draw').className = mode === 'DRAW' ? 'mode-btn active' : 'mode-btn';
            document.getElementById('view-controls').style.display = mode === 'VIEW' ? 'block' : 'none';
            document.getElementById('draw-controls').style.display = mode === 'DRAW' ? 'block' : 'none';
            
            if(mode === 'DRAW') {
                CONFIG.shape = 'custom';
                STATE.drawIndex = 0;
                for(let i=0; i<CONFIG.count*3; i++) shapes.custom[i] = 99999;
                STATE.pos.set(0,0,0); STATE.vel.set(0,0,0);
            }
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            STATE.smoothHand.lerp(STATE.hand1, 0.2);
            const targetShape = shapes[CONFIG.shape];
            const posAttr = geometry.attributes.position;

            // DRAWING
            if(CONFIG.appMode === 'DRAW') {
                cursor.visible = true;
                let inputPos = STATE.isMouseDrawing ? STATE.mouseWorld : (STATE.isHandDrawing ? STATE.smoothHand : null);
                
                if(STATE.isHandDrawing || STATE.activeHandId===1) cursor.position.copy(STATE.smoothHand);
                else cursor.position.copy(STATE.mouseWorld);

                if(inputPos) {
                    cursor.material.color.setHex(0xff00ff);
                    if(STATE.activeHandId) cursor.rotation.z += 0.2;
                    
                    const dist = inputPos.distanceTo(STATE.lastDrawPos);
                    if(dist > 0.05 || STATE.drawIndex === 0) {
                        const steps = Math.min(20, Math.ceil(dist/0.05));
                        for(let s=0; s<=steps; s++) {
                            if(STATE.drawIndex >= CONFIG.count) break;
                            const t = s/steps;
                            const v = new THREE.Vector3().lerpVectors(STATE.lastDrawPos, inputPos, t);
                            const idx = STATE.drawIndex*3;
                            shapes.custom[idx]=v.x; shapes.custom[idx+1]=v.y; shapes.custom[idx+2]=v.z;
                            STATE.drawIndex++;
                        }
                        STATE.lastDrawPos.copy(inputPos);
                    }
                } else {
                    cursor.material.color.setHex(0x00ffff);
                    cursor.rotation.z = 0;
                    if(STATE.activeHandId) STATE.lastDrawPos.copy(STATE.smoothHand);
                    else STATE.lastDrawPos.copy(STATE.mouseWorld);
                }
            } else {
                cursor.visible = false;
            }

            // PARTICLES MOVEMENT
            for(let i=0; i<CONFIG.count; i++) {
                const ix = i*3;
                let tx = targetShape[ix]; let ty = targetShape[ix+1]; let tz = targetShape[ix+2];

                if(STATE.mode === 'GRAB') { tx*=0.8; ty*=0.8; tz*=0.8; } // –°–∂–∞—Ç–∏–µ –ø—Ä–∏ –≥—Ä–∞–±–µ

                if(STATE.entropy > 0.01) {
                    tx += STATE.scatterOffset[ix] * STATE.entropy;
                    ty += STATE.scatterOffset[ix+1] * STATE.entropy;
                    tz += STATE.scatterOffset[ix+2] * STATE.entropy;
                }

                // Smooth morphing
                posAttr.array[ix] += (tx - posAttr.array[ix]) * 0.08;
                posAttr.array[ix+1] += (ty - posAttr.array[ix+1]) * 0.08;
                posAttr.array[ix+2] += (tz - posAttr.array[ix+2]) * 0.08;
            }
            posAttr.needsUpdate = true;

            // PHYSICS CONTAINER
            if(CONFIG.appMode === 'VIEW') {
                const activePos = (STATE.activeHandId === 2) ? STATE.hand2 : STATE.smoothHand;

                if (STATE.mode === 'GRAB') {
                    STATE.pos.lerp(activePos, 0.1);
                    STATE.rotVel.x *= 0.9; STATE.rotVel.y *= 0.9;
                } else if (STATE.mode === 'ROTATE') {
                    const dX = activePos.x - STATE.prevHand.x;
                    const dY = activePos.y - STATE.prevHand.y;
                    STATE.rotVel.y += dX * 0.3;
                    STATE.rotVel.x -= dY * 0.3;
                } else {
                    STATE.pos.add(STATE.vel);
                    STATE.vel.multiplyScalar(CONFIG.spinFriction);
                    if(Math.abs(STATE.pos.x)>15) STATE.vel.x*=-1;
                    if(Math.abs(STATE.pos.y)>10) STATE.vel.y*=-1;
                    particles.rotation.y += 0.001;
                }
                
                particles.rotation.x += STATE.rotVel.x * 0.1;
                particles.rotation.y += STATE.rotVel.y * 0.1;
                STATE.rotVel.x *= CONFIG.spinFriction; STATE.rotVel.y *= CONFIG.spinFriction;

                STATE.scale += (STATE.scale - STATE.scale) * 0.1; 
                particles.scale.setScalar(STATE.scale);
                particles.position.copy(STATE.pos);
                STATE.prevHand.copy(activePos);
            } else {
                particles.position.set(0,0,0);
                particles.rotation.set(0,0,0);
                particles.scale.setScalar(1);
            }

            // RENDER (Use Composer for Bloom)
            composer.render();
        }


        // --- INPUT HANDLING ---
        window.addEventListener('mousemove', e => {
            STATE.mouse.x = (e.clientX/window.innerWidth)*2 - 1;
            STATE.mouse.y = -(e.clientY/window.innerHeight)*2 + 1;
            raycaster.setFromCamera(STATE.mouse, camera);
            raycaster.ray.intersectPlane(drawPlane, STATE.mouseWorld);
        });
        window.addEventListener('mousedown', () => { if(CONFIG.appMode==='DRAW') STATE.isMouseDrawing=true; });
        window.addEventListener('mouseup', () => STATE.isMouseDrawing=false);
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });


        // --- MEDIAPIPE LOGIC ---
        const uiMode = document.getElementById('mode-disp');
        const loader = document.getElementById('loader');

        function onResults(results) {
            if(loader) loader.style.display = 'none';
            const count = results.multiHandLandmarks ? results.multiHandLandmarks.length : 0;
            
            let h1=null, x1=0, y1=0;
            if(count>0) {
                const lm1 = results.multiHandLandmarks[0];
                h1 = analyze(lm1);
                x1 = (1 - lm1[9].x - 0.5) * 25; y1 = (1 - lm1[9].y - 0.5) * 15;
            }
            if(count>1) {
                const lm2 = results.multiHandLandmarks[1];
                const x2 = (1 - lm2[9].x - 0.5) * 25; const y2 = (1 - lm2[9].y - 0.5) * 15;
                STATE.hand2.set(x2,y2,0);
            }

            if(CONFIG.appMode === 'DRAW') {
                if(h1 && h1.isPinch) {
                    setAppMode('VIEW');
                    AudioSys.playTone(600);
                    return;
                }
                if(h1 && h1.isGrab) {
                    STATE.activeHandId = 1; STATE.hand1.set(x1,y1,0); STATE.isHandDrawing=true;
                    updateMode('DRAWING (FIST)');
                } else {
                    STATE.isHandDrawing=false;
                    if(h1) { STATE.hand1.set(x1,y1,0); STATE.activeHandId=1; }
                    updateMode('CURSOR');
                }
                return;
            }

            // View Mode
            if(count===2) { // Dual hand entropy
                 STATE.hand1.set(x1, y1, 0);
                 const dist = STATE.hand1.distanceTo(STATE.hand2);
                 STATE.entropy = (dist < 5) ? 0 : Math.min(1.0, (dist-5)/10);
                 updateMode('DUAL HANDS');
                 return;
            } else { STATE.entropy = 0; }

            if(count>0) {
                STATE.activeHandId = 1; STATE.hand1.set(x1,y1,0);
                if(h1.isGrab) { updateMode('GRAB'); return; }
                if(h1.isPinch) {
                    if(STATE.mode!=='RESIZE') { STATE.resizeBaseY=y1; STATE.resizeBaseS=STATE.scale; }
                    STATE.scale = Math.max(0.3, Math.min(3.0, STATE.resizeBaseS + (y1-STATE.resizeBaseY)*0.3));
                    updateMode('RESIZE');
                    return;
                }
                if(h1.isOpen) { updateMode('ROTATE'); return; }
            }
            updateMode('IDLE');
        }

        function analyze(lm) {
            const isIndexUp = lm[8].y < lm[6].y;
            const isMiddleUp = lm[12].y < lm[10].y;
            const isRingUp = lm[16].y < lm[14].y;
            const isPinkyUp = lm[20].y < lm[18].y;
            const pinchDist = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
            
            const fingers = [isIndexUp, isMiddleUp, isRingUp, isPinkyUp].filter(Boolean).length;
            return { isGrab: fingers<=1, isPinch: pinchDist<0.05 && isMiddleUp, isOpen: fingers>=4 };
        }

        function updateMode(m) {
            if(STATE.mode === m) return;
            STATE.mode = m;
            uiMode.innerText = m;
            if(m==='GRAB') AudioSys.playTone(150, 'sawtooth');
            if(m==='RESIZE') AudioSys.playTone(400, 'sine');
        }

        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}` });
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        hands.onResults(onResults);
        
        const cam = new Camera(document.getElementById('video-feed'), {
            onFrame: async () => await hands.send({image: document.getElementById('video-feed')}),
            width: 640, height: 480
        });
        cam.start();
        animate();
    </script>
</body>
</html>
