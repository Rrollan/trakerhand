<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>HAND PHYSICS V8: MOMENTUM MEMORY</title>
    <style>
        /* --- VISUALS --- */
        body { margin: 0; overflow: hidden; background-color: #020202; font-family: 'Segoe UI', sans-serif; color: white; user-select: none; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; filter: drop-shadow(0 0 10px rgba(0, 255, 255, 0.2)); }
        #video-feed { position: absolute; bottom: 20px; left: 20px; width: 180px; height: 135px; z-index: 2; border-radius: 12px; border: 1px solid rgba(255, 255, 255, 0.3); transform: scaleX(-1); opacity: 0; transition: opacity 1s; }
        
        #ui-panel { position: absolute; top: 20px; right: 20px; width: 260px; padding: 25px; background: rgba(15, 15, 15, 0.85); backdrop-filter: blur(16px); border-radius: 20px; border: 1px solid rgba(255, 255, 255, 0.1); z-index: 10; }
        h2 { margin: 0 0 15px 0; font-size: 12px; text-transform: uppercase; color: #00ffff; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px; }
        .grid-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 20px; }
        button { background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); color: #aaa; padding: 10px; border-radius: 8px; cursor: pointer; transition: 0.2s; font-size: 11px; text-transform: uppercase; }
        button:hover { background: rgba(255, 255, 255, 0.15); color: #fff; }
        button.active { background: rgba(0, 255, 255, 0.2); border-color: #00ffff; color: #00ffff; }
        
        .status-box { margin-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 10px; font-size: 11px; color: #aaa; line-height: 1.8; }
        .key { color: #fff; font-weight: bold; }
        #mode-display { font-size: 14px; color: #00ffff; font-weight: bold; margin-top: 5px; text-align: center; background: rgba(255,255,255,0.05); padding: 5px; border-radius: 4px;}

        #loader { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; transition: opacity 0.8s; }
        .spinner { width: 40px; height: 40px; border: 3px solid rgba(255,255,255,0.1); border-top-color: #00ffff; border-radius: 50%; animation: spin 1s infinite linear; margin-bottom: 15px; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js"></script>
</head>
<body>

    <div id="loader"><div class="spinner"></div><div style="color: #00ffff; font-size: 12px;">LOADING PHYSICS V8...</div></div>

    <div id="ui-panel">
        <h2>Control Panel</h2>
        <div class="grid-buttons" id="shape-buttons">
            <button onclick="setShape('sphere')" class="active">Sphere</button>
            <button onclick="setShape('galaxy')">Galaxy</button>
            <button onclick="setShape('heart')">Heart</button>
            <button onclick="setShape('cube')">Cube</button>
        </div>
        <div class="status-box">
            <div><span class="key">‚òùÔ∏è Index:</span> PUSH / DRAG</div>
            <div><span class="key">üëã Release:</span> <b>AUTO DRIFT</b></div>
            <div><span class="key">üëç Thumb:</span> STOP / BRAKE</div>
            <div><span class="key">‚úåÔ∏è Victory:</span> Resize</div>
            <div><span class="key">‚úä Fist:</span> Grab</div>
            <div id="mode-display">IDLE</div>
            <div id="debug-vel" style="text-align:center; font-family:monospace; margin-top:5px; font-size:10px;">Speed: 0.00</div>
        </div>
    </div>

    <video id="video-feed" playsinline></video>
    <div id="canvas-container"></div>

    <script>
        // --- CONFIG ---
        const CONFIG = {
            count: 7000,
            size: 0.12,
            shape: 'sphere',
            bounds: { x: 16, y: 10 },
            friction: 0.99, // Very slippery (keeps momentum)
        };

        const STATE = {
            pos: new THREE.Vector3(0,0,0),    
            vel: new THREE.Vector3(0,0,0),    
            
            // Hand Tracking
            handPos: new THREE.Vector3(0,0,0),
            prevHandPos: new THREE.Vector3(0,0,0),
            
            // Physics Memory
            momentum: new THREE.Vector3(0,0,0), // Smoothed velocity
            
            rot: {x:0, y:0},
            scale: 1.0, 
            mode: 'IDLE',
            
            lastMoveTime: 0
        };

        // --- THREE.JS ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020202, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 8;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        function getTexture() {
            const c = document.createElement('canvas'); c.width=64; c.height=64;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(32,32,0,32,32,32);
            g.addColorStop(0,'rgba(255,255,255,1)');
            g.addColorStop(0.3,'rgba(220,240,255,0.8)');
            g.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle=g; ctx.fillRect(0,0,64,64);
            return new THREE.CanvasTexture(c);
        }

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.count * 3);
        const colors = new Float32Array(CONFIG.count * 3);
        const shapes = { sphere: [], galaxy: [], heart: [], cube: [] };
        const c3 = new THREE.Color();

        // Shapes
        for(let i=0; i<CONFIG.count; i++) {
            const phi = Math.acos(-1 + (2*i)/CONFIG.count);
            const theta = Math.sqrt(CONFIG.count * Math.PI) * phi;
            shapes.sphere.push(2.5*Math.cos(theta)*Math.sin(phi), 2.5*Math.sin(theta)*Math.sin(phi), 2.5*Math.cos(phi));
            
            const angle = i*0.1; const r = (i/CONFIG.count)*5;
            shapes.galaxy.push((r*Math.cos(angle)), (Math.random()-0.5)*0.5, (r*Math.sin(angle)));
            
            const t = (i/CONFIG.count)*Math.PI*2;
            const hx = 16*Math.pow(Math.sin(t),3);
            const hy = 13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
            shapes.heart.push(hx*0.15, hy*0.15, (Math.random()-0.5));
            shapes.cube.push((Math.random()-0.5)*4, (Math.random()-0.5)*4, (Math.random()-0.5)*4);

            c3.setHSL(i/CONFIG.count, 0.8, 0.6);
            colors[i*3]=c3.r; colors[i*3+1]=c3.g; colors[i*3+2]=c3.b;
        }

        positions.set(shapes.sphere);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: CONFIG.size, map: getTexture(), vertexColors: true,
            blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 0.9
        });
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- ANIMATION LOOP ---
        window.setShape = (n) => {
            CONFIG.shape = n;
            document.querySelectorAll('#shape-buttons button').forEach(b=>b.classList.remove('active'));
            event.target.classList.add('active');
        }

        function animate() {
            requestAnimationFrame(animate);

            const targetShape = shapes[CONFIG.shape];
            const posAttr = geometry.attributes.position;
            const colAttr = geometry.attributes.color;
            const time = Date.now() * 0.001;
            const isGrab = (STATE.mode === 'GRAB');

            // 1. Morphing
            for(let i=0; i<CONFIG.count; i++) {
                const ix = i*3;
                let tx = targetShape[ix]; let ty = targetShape[ix+1]; let tz = targetShape[ix+2];

                if(isGrab) { tx *= 0.9; ty *= 0.9; tz *= 0.9; tx += (Math.random()-0.5)*0.1; ty += (Math.random()-0.5)*0.1; } 

                posAttr.array[ix] += (tx - posAttr.array[ix]) * 0.1;
                posAttr.array[ix+1] += (ty - posAttr.array[ix+1]) * 0.1;
                posAttr.array[ix+2] += (tz - posAttr.array[ix+2]) * 0.1;

                // Colors
                let h=(i/CONFIG.count+time*0.1)%1; let s=0.8; let l=0.6;
                if(STATE.mode === 'GRAB') { h=0.5; s=0.2; l=1.0; } // White
                else if(STATE.mode === 'LOCKED') { h=0.0; s=0.0; l=0.3; } // Grey
                else if(STATE.mode === 'RESIZE') { h=0.3; s=1.0; l=0.6; } // Green
                else if(STATE.mode === 'MOVE') { h=0.6; s=0.9; l=0.7; } // Blue
                else if(STATE.mode === 'DRIFT') { h=0.8; s=1.0; l=0.6; } // Magenta
                c3.setHSL(h,s,l);
                colAttr.array[ix]=c3.r; colAttr.array[ix+1]=c3.g; colAttr.array[ix+2]=c3.b;
            }
            posAttr.needsUpdate = true; colAttr.needsUpdate = true;

            // 2. PHYSICS CORE
            
            // Calculate Momentum (The fix for "stopping before release")
            // We constantly calculate speed while holding, and smooth it
            if (STATE.mode === 'MOVE' || STATE.mode === 'GRAB') {
                const instantDelta = new THREE.Vector3().subVectors(STATE.handPos, STATE.prevHandPos);
                // "Lerp" the momentum. This remembers the speed from a few frames ago.
                STATE.momentum.lerp(instantDelta, 0.2); 
            }

            // MODE LOGIC
            if (STATE.mode === 'MOVE') {
                STATE.pos.lerp(STATE.handPos, 0.2);
            
            } else if (STATE.mode === 'GRAB') {
                STATE.pos.lerp(STATE.handPos, 0.4);

            } else if (STATE.mode === 'DRIFT') {
                // APPLY MOMENTUM
                STATE.pos.add(STATE.vel);
                STATE.vel.multiplyScalar(CONFIG.friction); // Slow down very slowly

                // Wall Bounce
                if(STATE.pos.x > CONFIG.bounds.x || STATE.pos.x < -CONFIG.bounds.x) STATE.vel.x *= -0.7;
                if(STATE.pos.y > CONFIG.bounds.y || STATE.pos.y < -CONFIG.bounds.y) STATE.vel.y *= -0.7;
                
                particles.rotation.z += STATE.vel.x * 0.1;
                particles.rotation.x += STATE.vel.y * 0.1;

            } else if (STATE.mode === 'RESIZE') {
                let targetS = 1.0 + (STATE.handPos.y * 0.4); 
                targetS = Math.max(0.5, Math.min(3.5, targetS));
                STATE.scale += (targetS - STATE.scale) * 0.1;

            } else if (STATE.mode === 'ROTATE') {
                 particles.rotation.y += (STATE.rot.x - particles.rotation.y) * 0.1;
                 particles.rotation.x += (STATE.rot.y - particles.rotation.x) * 0.1;
                 // Slow down drift if rotating
                 STATE.vel.multiplyScalar(0.9);
            }

            particles.position.copy(STATE.pos);
            particles.scale.setScalar(STATE.scale);
            
            STATE.prevHandPos.copy(STATE.handPos);
            
            // Debug speed
            document.getElementById('debug-vel').innerText = "Speed: " + STATE.vel.length().toFixed(3);

            renderer.render(scene, camera);
        }

        // --- HANDS ---
        const uiMode = document.getElementById('mode-display');
        const loader = document.getElementById('loader');
        const videoElement = document.getElementById('video-feed');

        function onResults(results) {
            if(loader.style.opacity !== '0') {
                loader.style.opacity = '0';
                setTimeout(()=>loader.style.display='none', 800);
                videoElement.style.opacity = '1';
            }

            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                // No hands? Just keep drifting!
                if(STATE.mode === 'MOVE' || STATE.mode === 'GRAB') {
                     launchDrift();
                }
                return;
            }

            const lm = results.multiHandLandmarks[0];

            // Fingers
            const isIndexUp = lm[8].y < lm[6].y;
            const isMiddleUp = lm[12].y < lm[10].y;
            const isRingUp = lm[16].y < lm[14].y;
            const isPinkyUp = lm[20].y < lm[18].y;
            const isThumbOpen = Math.hypot(lm[4].x - lm[17].x, lm[4].y - lm[17].y) > 0.25;

            let fingers = [isIndexUp, isMiddleUp, isRingUp, isPinkyUp].filter(Boolean).length;
            if(isThumbOpen) fingers++;

            // Map Pos
            const x = (1 - lm[9].x - 0.5) * 20; 
            const y = (1 - lm[9].y - 0.5) * 12;
            STATE.handPos.set(x, y, 0);

            // --- PRIORITY LOGIC ---

            // 1. BRAKE (Thumb only)
            if (fingers === 1 && isThumbOpen && !isIndexUp) {
                updateMode('LOCKED');
                STATE.vel.set(0,0,0); // KILL MOMENTUM
                return;
            }

            // 2. GRAB (Fist)
            if (fingers <= 1 && !isThumbOpen) {
                updateMode('GRAB');
                return;
            }

            // 3. RESIZE (Victory)
            if (isIndexUp && isMiddleUp && !isRingUp && !isPinkyUp) {
                updateMode('RESIZE');
                return;
            }

            // 4. MOVE (Index)
            if (isIndexUp && !isMiddleUp) {
                updateMode('MOVE');
                return;
            }

            // 5. OPEN PALM -> DRIFT or ROTATE
            if (fingers >= 4) {
                // THE FIX: If we were moving/grabbing, LAUNCH into DRIFT
                // Only go to ROTATE if we are already stopped.
                if (STATE.mode === 'GRAB' || STATE.mode === 'MOVE') {
                    launchDrift();
                    return;
                }
                
                // If velocity is high, keep drifting, ignore rotation
                if (STATE.vel.length() > 0.1) {
                    updateMode('DRIFT');
                } else {
                    updateMode('ROTATE');
                    STATE.rot.x = (lm[9].x - 0.5) * 5;
                    STATE.rot.y = (lm[9].y - 0.5) * 5;
                }
                return;
            }
        }

        function launchDrift() {
            updateMode('DRIFT');
            // Transfer stored momentum to physics velocity
            // Boost it a bit (x3) so it feels powerful
            STATE.vel.copy(STATE.momentum).multiplyScalar(3.0);
        }

        function updateMode(m) {
            if(STATE.mode === m) return;
            STATE.mode = m;
            uiMode.innerText = m;
            
            if(m==='GRAB') uiMode.style.color = 'white';
            else if(m==='LOCKED') uiMode.style.color = 'red';
            else if(m==='DRIFT') uiMode.style.color = 'magenta';
            else if(m==='RESIZE') uiMode.style.color = '#00ff00';
            else uiMode.style.color = '#00ffff';
        }

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });
        hands.onResults(onResults);

        const cam = new Camera(videoElement, {
            onFrame: async () => await hands.send({image: videoElement}),
            width: 640, height: 480
        });
        cam.start();
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>